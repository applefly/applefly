<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[逻辑回归与线性回归原理探微]]></title>
      <url>http://onesimple.cn//blog/2017/02/logistic-regression/</url>
      <content type="html"><![CDATA[<center><br><img alt="封面" class="class1 class2" src="http://okqpu7sb4.bkt.clouddn.com//image/cover/ml.jpg?imageView2/2/w/600"><br></center>

<p>&emsp;&emsp;回归和分类是机器学习解决的最重要的问题，本篇主要整理了线性回归和逻辑回归的基本推理过程和工程实践应用，首先对两种回归的方法做一下比较:</p>
<blockquote>
<p>线性回归: 最小二乘法推导，预测连续值</p>
<p>逻辑回归: 基于最大似然估计，主要解决二分类问题，也可用于连续值的预测</p>
</blockquote>
<a id="more"></a>
<h1 id="1-线性回归"><a href="#1-线性回归" class="headerlink" title="1.线性回归"></a>1.线性回归</h1><h2 id="问题引出"><a href="#问题引出" class="headerlink" title="问题引出"></a>问题引出</h2><p>&emsp;&emsp;房价y和房屋面积x之间的关系，我们一般估计为线性关系，即目标函数为:</p>
<p>$$<br>    f(x) = ax + b<br>$$<br>$$<br>   f(x) \approx  y<br>$$<br>根据样本很容易计算出a、b，也就能根据一个给定的面积x估算出房价了。\<br>如果有影响房价的不止一个因素(现实中往往如此，比如国民平均收入水平也是影响房价的一个因素)，就是一个多变量问题，这时我们估计的目标函数就变成多元的了，如果有m个因素,记为列向量:<br>$$\sum_{i=1}^n a_i=0$$</p>
<p>$$<br>    x = (x_0,x_1,…,x_{m-1})<br>$$<br>则要求解的参数w的也应该是m个，也记为列向量<br>$$<br>    w =<br>        \left (<br>            \begin{matrix}<br>                w_0 \\<br>                w_1 \\<br>                … \\<br>                w_{m-1}<br>            \end{matrix}<br>        \right )<br>$$<br>预测的f(x)是一个值，<code>f(x) = ax +b</code>的形式就变成:<br>$$<br>    f = xw<br>$$<br>推广到样本空间，记第i个样本为:<br>$$<br>    x_i = (x_{i0}, x_{i1},…,x_{i,m-1})<br>$$<br>如果有n个样本，样本空间表示为矩阵X:<br>$$<br>    X_{n \times m} =<br>        \left (<br>            \begin{matrix}<br>                x_{00} &amp; x_{01} &amp; … &amp; x_{0,m-1} \\<br>                x_{10} &amp; x_{11} &amp; … &amp; x_{1,m-1} \\<br>                …    &amp; … &amp; … &amp; …          \\<br>                x_{n-1,0} &amp; x_{n-1,1} &amp; … &amp; x_{n-1,m-1}<br>            \end{matrix}<br>        \right )<br>$$<br>则预测的所有f值的向量为:<br>$$<br>    f_{n \times 1} =<br>            \left (<br>            \begin{matrix}<br>                f_0 \\<br>                f_1 \\<br>                … \\<br>                f_{n-1}<br>            \end{matrix}<br>        \right )<br>        =<br>        X_{n \times m}w_{m \times 1}<br>$$<br>预测值和实际值一般会有一个误差，记为e<br>$$<br>  y_{n \times 1} = f_{n \times 1} + e_{n \times 1}<br>$$<br>任意第i个样本跟预测结果的误差的分布是随机的，既然是随机的，根据中心极限定理就可以估计其分布为正态分布，均值为0，方差为定值，则依据正态分布的概率密度定义,预测值与实际值之间误差的概率密度为:</p>
<p>$$<br>  p({e^{(i)}}) = \frac    {1}<br>      {<br>           \sqrt[2]  {2\pi}<br>           \sigma<br>      }<br>      e^{( - \frac { ( {e^{(i)}} ) ^ 2}<br>          {2\sigma^2}<br>      )}<br>$$<br>其中<br>$$<br>{e^{(i)}} = {y^{(i)}} - w_{m \times 1}^T {x_{m \times 1}^{(i)}}<br>$$<br>此式代入上式。假定n个样本独立，则n个样本的最大似然函数是各自概率密度的乘积:<br>$$<br>L(w) = \prod_{i=1}^{n} \frac    {1}<br>      {<br>           \sqrt[2]  {2\pi}<br>           \sigma<br>      }<br>      e^{( - \frac { ( {e^{(i)}} ) ^ 2}<br>          {2\sigma^2}<br>      )}<br>$$<br>此式是关于w的似然函数，要求的是w，可以先对上式取对数,得:<br>$$<br>l(w) = \sum_{i=1}^{n} \ln  [ {<br>       \frac    {1}<br>      {<br>           \sqrt[2]  {2\pi}<br>           \sigma<br>      }<br>      e^{( - \frac { ( {e^{(i)}} ) ^ 2}<br>          {2\sigma^2}<br>      )}<br>      } ]    \\\\<br>     = n \ln (\frac {1} { \sqrt[2]  {2\pi} \sigma }) -<br>     \frac {1} {2\sigma^2} \sum_{i=1}^{n} ({y^{(i)}} - w_{n \times 1}^T {x_{n \times 1}^{(i)}})^2<br>$$<br>前半项是常数项，记后半项为:<br>$$ \begin{equation}<br>J(w) = \frac {1} {2} {\sum_{i=1}^{n} ({y^{(i)}} - w_{n \times 1}^T {x_{n \times 1}^{(i)}})^2} \\\\<br>     = \frac {1} {2} {\sum_{i=1}^{n} (f_w(x) - y)^2}<br>     \label{a0} \end{equation}<br>$$</p>
<blockquote>
<p>l(w) J(w) 都是一个数值，根据最大似然估计法，概率总和最大时参数估计的最合理，则最大似然函数L(w)取最大时，可推出J(w)取最小，J(w)为最小二乘法的目标函数，问题变为求目标函数最小值的问题。</p>
</blockquote>
<h2 id="参数学习"><a href="#参数学习" class="headerlink" title="参数学习"></a>参数学习</h2><p>X为nxm的样本矩阵，Y为nx1维列向量，J(w)可以写成以下形式:<br>$$<br>\begin{equation}<br>J(w) = \frac {1} {2} (Xw - Y)^T(Xw - Y)<br>\label{a1}<br>\end{equation}<br>$$<br>要求J(w)的极值，可对上式求偏导:<br>$$<br>\nabla _w J(w) = \nabla _w (Xw - Y)^T(Xw - Y) \\\\<br>= \nabla _w (w^T X^T X w - w^T X^T Y - Y^T X w - Y^T Y) \\\\<br>= 2 X^T X w - X^T Y - (Y^T X)^T \\\\<br>= 2 ( X^T X w - X^T Y )<br>$$</p>
<p>注意:</p>
<blockquote>
<p>$Y^T X$  是常数项对w求偏导为0<br>$ \frac{\partial Xw}{\partial w} = X^\mathrm {T} $</p>
</blockquote>
<p>令上式偏导等于0，求解w:<br>$$<br>w = ( X^\mathrm {T} X ) ^ {-1} X^\mathrm {T} Y<br>$$<br>为防止$ X^\mathrm {T} X $ 不可逆或者防止过拟合，增加扰动$\lambda $<br>$$<br>\begin{equation}<br>w = ( X^\mathrm {T} X + \lambda I ) ^ {-1} X^\mathrm {T} Y<br>\label{a2}<br>\end{equation}<br>$$<br>I为单位阵，以上就是线性回归数理上的最终结论。</p>
<h2 id="正则化处理"><a href="#正则化处理" class="headerlink" title="正则化处理"></a>正则化处理</h2><p>过拟合是指在样本集上表现良好，但测试集上不好，一般是w中有些值过大，振荡很大，而导致过拟合。<br>为解决这个问题可以让更多的$w_j$取0，且越多越好，这种处理方法叫$L_0$正则化；<br>一般是让$ \sum_{j=1}^{m} |w_j| $ 取最小，这种处理叫$L_0$正则化；<br>如果是让$ \sum_{j=1}^{m} |w_j|^2 $ 取最小，则称谓$L_2$正则化。<br>故目标函数 $(\ref{a1})$ 加入平方和损失:<br>$$<br>\begin{equation}<br>J(w) = \frac {1} {2} (Xw - Y)^T(Xw - Y) + \lambda \sum_{j=1}^{m} {w_j}^2<br>\end{equation}<br>$$<br>根据此式进行求解也能推出w的求解公式$(\ref{a2})$</p>
<h2 id="训练与评价"><a href="#训练与评价" class="headerlink" title="训练与评价"></a>训练与评价</h2><p>怎么对样本进行训练呢?对于正则化项$\lambda$,怎么取值合理呢？</p>
<p>|  <strong><code>------- 1 -------</code></strong>    | <strong><code>-- 2 --</code></strong> |<strong><code>-- 3 --</code></strong>|</p>
<p>按合适比例划分样本，得到1、2、3三个部分<br>区间1用于训练w<br>区间2可以试用不同的$\lambda$，使用$w+\lambda I $作预测，看$\lambda$取多少时预测的准确，则选定此$\lambda$，这个过程不需要严格。<br>区间3对w、$\lambda$ 进行验证，当然，还有些交叉验证的策略。<br>|  <strong><code>------------  训练 -------------</code></strong>    | <strong><code>10% 验证</code></strong> |<br>|  <strong><code>--------  训练 ---------</code></strong>    | <strong><code>10%验证</code></strong> | <strong><code>- 训练-</code></strong> |<br>… …       交叉训练验证走十次       … …</p>
<h2 id="梯度下降算法"><a href="#梯度下降算法" class="headerlink" title="梯度下降算法"></a>梯度下降算法</h2><p>公式$(\ref{a2})$是参数w的解析解,但实际工程中样本空间很大，不可能对样本空间进行矩阵运算，所以这就需要机器学习的思路，从参数迭代的角度来求解w,梯度下降是常用的算法。</p>
<blockquote>
<p>其意义是，为了求得函数的极值点(局部最小值)，先任取一点，然后沿此点处梯度的负方向进行迭代到一个新的点，继续下降直到收敛，算法结束。</p>
</blockquote>
<p>首先我们来对$(\ref{a0})$某个$w_j$求偏导<br>$$<br> \frac{\partial J(w)}{\partial w_j} = \frac{\partial }{\partial w_j} { \frac {1} {2} (f_w (x) - y)^2 } \\\\<br> = (f_w (x) - y) \cdot \frac{\partial }{\partial w_j} (f_w (x) - y)\\\\<br> = (f_w (x) - y) \cdot \frac{\partial }{\partial w_j} (\sum_{k=1}^{m} w_k x_k - y) \\\\<br> = (f_w (x) - y) x_j<br>$$<br>注意，上式除了$w_j$其他都算常量，所以求导得到上式结果。结论可简记为：</p>
<blockquote>
<p>某个维度的梯度 = 预测误差 X 样本在该维度的取值</p>
</blockquote>
<p>既然有了这个梯度，我们就可以有以下几种方式计算。</p>
<h3 id="批量梯度下降"><a href="#批量梯度下降" class="headerlink" title="批量梯度下降"></a>批量梯度下降</h3><p><strong>批量梯度下降是对所有样本的梯度做加和，然后按步长进行下降迭代，直到收敛</strong></p>
<p>while  重复直到收敛 :  {<br>$$ w_j = w_j + \alpha \sum_{i=1}^{n} [ (y^{(i)} - f_w(x^{(i)})) \cdot x_j^{(i)} ] $$<br>}<br>$\alpha$为每次迭代的步长<br>凸函数局部最小值一定是全局最小值，批量梯度下降一定会收敛。<br>初始可以让w都为0</p>
<h3 id="随机梯度下降SGD"><a href="#随机梯度下降SGD" class="headerlink" title="随机梯度下降SGD"></a>随机梯度下降SGD</h3><p>随机梯度下降也称SGD<br><strong>针对每来一个样本进行一次迭代，而不是对所有样本的梯度做加和做迭代</strong><br>while 迭代次数  :  {<br>&emsp;&emsp;for i = 0 to n : {<br>$$<br>w_j = w_j + \alpha (y^{(i)} - f_w(x^{(i)})) \cdot x_j^{(i)}<br>$$<br>&emsp;&emsp;}<br>}<br>注:可以通过最大迭代次数来退出loop，也可以判断本次参数$w_j^{(k)}$ 和下次的$w_j^{(k+1)}$之间的误差，如果稳定到很小的值，则认为收敛，可以退出。</p>
<blockquote>
<p>全局梯度下降有可能在一些拐点位置停止不前，而随机梯度下降就或许能跳过一些拐点到达真正的收敛点附近，这是梯度下降的一些特点，以后有机会附文研讨。<br>随机梯度下降一般速度会比较快，学习步长也可以让它先大后小。</p>
</blockquote>
<h3 id="mini-batch梯度下降"><a href="#mini-batch梯度下降" class="headerlink" title="mini-batch梯度下降"></a>mini-batch梯度下降</h3><p>基于以上两种算法的折中算法，每次随机选取b个样本做一个批量梯度下降，这样既节省了计算整个批量的时间，同时计算的方向也会像SGD一样更加准确。<br>repeat until convergency{<br>&emsp;&emsp;for i=1;i&lt;n ; i+=b: {<br>$$ w_j = w_j + \alpha \sum_{i=1}^{i+b} [ (y^{(i)} - f_w(x^{(i)})) \cdot x_j^{(i)} ] $$<br>&emsp;&emsp;}<br>}
　</p>
<h1 id="2-非线性回归"><a href="#2-非线性回归" class="headerlink" title="2.非线性回归"></a>2.非线性回归</h1><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>其实只是特征增加了$x^2$项，y相对于特征是非线性的，相对于w还是线性的。往往可以先通过变量置换，$x^{‘} = x^2$把非线性回归化为线性回归，再利用线性回归的方法确定参数及估计值。</p>
<blockquote>
<p><strong>局部加权回归暂不介绍</strong></p>
</blockquote>
<h1 id="3-逻辑回归"><a href="#3-逻辑回归" class="headerlink" title="3.逻辑回归"></a>3.逻辑回归</h1><h2 id="问题引出-1"><a href="#问题引出-1" class="headerlink" title="问题引出"></a>问题引出</h2><p>线性回归适合预测连续值，在解决分类问题时则有些不合理，比如<br>如果只有A B 两簇，线性回归拟合直线为$L_1$,此时取定义域中点a处的值作为界限进行分类，可能暂时满足。但当是ABC三簇数据时，再依此法取b出的值作为分类界限，就会发现分类很不合理。所以线性回归解决分类问题是不合理的，而逻辑回归则适合解决二分类问题。(如果解决多分类问题，可使用softmax回归)</p>
<center><br><img title="线性回归拟合直线" alt="线性回归拟合直线" class="class1 class2" src="http://okqpu7sb4.bkt.clouddn.com//image/data/line-rg1.png?imageView2/2/w/600"><br></center>

<p>逻辑回归虽然叫回归，但它实际是一种分类方法，主要解决分类问题，它的核心是利用了Logistic函数（也称Sigmoid函数），函数形式为:</p>
<p>$$<br>f{(x)} = \frac {1} {1 + e^{-x}}<br>$$</p>
<center><br><img title="Sigmoid函数" class="class1 class2" src="http://okqpu7sb4.bkt.clouddn.com//image/data/sigmoid.jpg?imageView2/2/w/600"><br></center>

<p>逻辑回归中，取预测值$w^Tx$为自变量，得</p>
<p>$$<br>f_w{(x)} = g(w^Tx) = \frac {1} {1 + e^{-{w^T}x}}<br>$$</p>
<p>上式可得到(0,1)区间的的分类预测值，以0.5为界进行划分即可完成分类。<br>要求解参数w，我们先对Sigmoid函数求偏导:<br>$$<br>g^{‘}{(x)} = ( \frac {1} {1 + e^{-x}} )^{‘} \\\\<br>    = \frac {e^{-x}} {(1+e^{-x})^2} \\\\<br>    = \frac {1} {1 + e^{-x}} \cdot { \frac {e^{-x}} {1+e^{-x}} } \\\\<br>    = \frac {1} {1 + e^{-x}} \cdot { (1 - {\frac {1} {1+e^{-x}}}) } \\\\<br>    = g(x)(1-g(x))<br>$$</p>
<center><br>《—- 待续 —-》<br></center>



]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[hexo博客之常用markdown语法及latex公式备忘]]></title>
      <url>http://onesimple.cn//blog/2017/01/write-blog-with-hexo/</url>
      <content type="html"><![CDATA[<p>本篇主要整理了一些常用的markdown语法，以及hexo博客使用mathjax渲染公式的一些样例。</p>
<a id="more"></a>
<ul>
<li>图片居中<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;center&gt;</div><div class="line">&#123;% qnimg user/alipay.jpg title:微信二维码 alt:二维码 &apos;class:class1 class2&apos; extend:?imageView2/2/w/600 %&#125;</div><div class="line">&lt;/center&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<center><br><img title="支付宝二维码" alt="二维码" class="class1 class2" src="http://okqpu7sb4.bkt.clouddn.com//image/user/alipay.jpg?imageView2/2/w/600"><br></center>

<ul>
<li>mathjax 公式测试<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">段内公式只用一个$即可:  $F_&#123;\mu&#125;$</div></pre></td></tr></table></figure>
</li>
</ul>
<p>&emsp;&emsp;这是我的段内公式: $F_{\mu}$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$$\sum_&#123;i=1&#125;^n a_i=0$$</div></pre></td></tr></table></figure>
<p>$$\sum_{i=1}^n a_i=0$$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$F_&#123;\mu&#125;$</div><div class="line"></div><div class="line">$F_1 + F_b = F_c$</div><div class="line"></div><div class="line">$$</div><div class="line">f(x) \approx  y</div><div class="line">$$</div></pre></td></tr></table></figure>
<p>$F_{\mu}$</p>
<p>$F_1 + F_b = F_c$</p>
<p>$$<br>f(x) \approx  y<br>$$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$x = ( x_0 , x_1 , ... , x_&#123;m-1&#125; )$</div></pre></td></tr></table></figure>
<p>$x = ( x_0 , x_1 , … , x_{m-1} )$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$$\sum_&#123;i=1&#125;^n a_i=0$$</div></pre></td></tr></table></figure>
<p>$$\sum_{i=1}^n a_i=0$$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$x = ( x_0 , x_1 , ... , x_&#123;m-1&#125; )$</div></pre></td></tr></table></figure>
<p>$x = ( x_0 , x_1 , … , x_{m-1} )$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$$</div><div class="line">\begin&#123;bmatrix&#125;</div><div class="line">1 &amp; 2\\</div><div class="line">3 &amp; 4</div><div class="line">\end&#123;bmatrix&#125;</div><div class="line">$$</div></pre></td></tr></table></figure>
<p>$$<br>\begin{bmatrix}<br>1 &amp; 2\\<br>3 &amp; 4<br>\end{bmatrix}<br>$$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$$</div><div class="line">    w = </div><div class="line">        \left (</div><div class="line">            \begin&#123;matrix&#125; </div><div class="line">                w\_0 \\</div><div class="line">                w\_1 \\</div><div class="line">                ... \\</div><div class="line">                w\_&#123;m-1&#125; </div><div class="line">            \end&#123;matrix&#125;</div><div class="line">        \right )</div><div class="line">$$</div></pre></td></tr></table></figure>
<p>$$<br>    w =<br>        \left (<br>            \begin{matrix}<br>                w_0 \\<br>                w_1 \\<br>                … \\<br>                w_{m-1}<br>            \end{matrix}<br>        \right )<br>$$</p>
<p>g^{‘}{(x)} = ( \frac {1} {1 + e^{-x}} )^{‘} \\\\<br>    = \frac {e^{-x}} {(1+e^{-x})^2} \\\\<br>    = \frac {1} {1 + e^{-x}} \cdot { \frac {e^{-x}} {1+e^{-x}} } \\\\<br>    = \frac {1} {1 + e^{-x}} \cdot { (1 - {\frac {1} {1+e^{-x}}}) } \\\\<br>    = g(x)(1-g(x))</p>
<p>$$<br>g^{‘}{(x)} = ( \frac {1} {1 + e^{-x}} )^{‘} \\\\<br>    = \frac {e^{-x}} {(1+e^{-x})^2} \\\\<br>    = \frac {1} {1 + e^{-x}} \cdot { \frac {e^{-x}} {1+e^{-x}} } \\\\<br>    = \frac {1} {1 + e^{-x}} \cdot { (1 - {\frac {1} {1+e^{-x}}}) } \\\\<br>    = g(x)(1-g(x))<br>$$</p>
<ul>
<li>表格测试<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">| 链接 | 结果 | 原因 |</div><div class="line">|:-----|:---:|----------:|</div><div class="line">|文本内容| **`是`** |同协议同域名同端口|</div><div class="line">|文本内容| **`是`** |同协议同域名同端口|</div><div class="line">|文本内容| **`是`** |同协议同域名同端口|</div></pre></td></tr></table></figure>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">链接</th>
<th style="text-align:center">结果</th>
<th style="text-align:right">原因</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">文本内容</td>
<td style="text-align:center"><strong><code>是</code></strong></td>
<td style="text-align:right">同协议同域名同端口</td>
</tr>
<tr>
<td style="text-align:left">文本内容</td>
<td style="text-align:center"><strong><code>是</code></strong></td>
<td style="text-align:right">同协议同域名同端口</td>
</tr>
<tr>
<td style="text-align:left">文本内容</td>
<td style="text-align:center"><strong><code>是</code></strong></td>
<td style="text-align:right">同协议同域名同端口</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[(转)C/C++ 程序的性能分析工具 google-perftools]]></title>
      <url>http://onesimple.cn//blog/2016/09/google-perftools/</url>
      <content type="html"><![CDATA[<p>&emsp;&emsp;google-perftools 是一款针对 C/C++ 程序的性能分析工具，它是一个遵守 BSD 协议的开源项目。使用该工具可以对 CPU 时间片、内存等系统资源的分配和使用进行分析，本文将重点介绍如何进行 CPU 时间片的剖析。 google-perftools 对一个程序的 CPU 性能剖析包括以下几个步骤。</p>
<a id="more"></a>
<blockquote>
<ol>
<li>编译目标程序，加入对 google-perftools 库的依赖。</li>
<li>运行目标程序，并用某种方式启动 / 终止剖析函数并产生剖析结果。</li>
<li>运行剖结果转换工具，将不可读的结果数据转化成某种格式的文档（例如 pdf,txt,gv 等）。</li>
</ol>
</blockquote>
<ul>
<li>安装</li>
</ul>
<p>&emsp;&emsp;您可以在 google-perftools 的网站 (<a href="http://code.google.com/p/google-perftools/downloads/list" target="_blank" rel="external">http://code.google.com/p/google-perftools/downloads/list</a>) 上下载最新版的安装包。为完成步骤 3 的工作，您还需要一个将剖析结果转化为程序员可读文档的工具，例如 gv（<a href="http://www.gnu.org/software/gv/）。" target="_blank" rel="external">http://www.gnu.org/software/gv/）。</a></p>
<ul>
<li>编译与运行</li>
</ul>
<p>&emsp;&emsp;您需要在原有的编译选项中加入对 libprofiler.so 的引用，这样在目标程序运行时会加载工具的动态库。例如本例中作者的系统中，libprofiler.so 安装在”/usr/lib”目录下，所以需要在 makefile 文件中的编译选项加入“-L/usr/lib -lprofiler”。</p>
<p>&emsp;&emsp;google-perftools 需要在目标代码的开始和结尾点分别调用剖析模块的启动和终止函数，这样在目标程序运行时就可以对这段时间内程序实际占用的 CPU 时间片进行统计和分析。工具的启动和终止可以采用以下两种方式。</p>
<p>&emsp;&emsp;a. 使用调试工具 gdb 在程序中手动运行性能工具的启动 / 终止函数。</p>
<p>&emsp;&emsp;gdb 是 Linux 上广泛使用的调试工具，它提供了强大的命令行功能，使我们可以在程序运行时插入断点并在断点处执行其他函数。具体的文档请参照 <a href="http://www.gnu.org/software/gdb/，本文中将只对用到的几个基本功能进行简单介绍。使用以下几个功能就可以满足我们性能" target="_blank" rel="external">http://www.gnu.org/software/gdb/，本文中将只对用到的几个基本功能进行简单介绍。使用以下几个功能就可以满足我们性能</a> 调试的基本需求，具体使用请参见下文示例。<br> 命令功能</p>
<blockquote>
<p>ctrl+c    暂停程序的运行 c    继续程序的运行 b    添加函数断点（参数可以是源代码中的行号或者一个函数名）<br>p    打印某个量的值或者执行一个函数调用 </p>
</blockquote>
<p>&emsp;&emsp;b. 在目标代码中直接加入性能工具函数的调用，该方法就是在程序代码中直接加入调试函数的调用。<br>&emsp;&emsp;两种方式都需要对目标程序重新编译，加入对性能工具的库依赖。对于前者，他的好处是使用比较灵活，但工具的启动和终止依赖于程序员的手动操作，常常 需要一 些暂停函数（比如休眠 sleep）的支持才能达到控制程序的目的，因此精度可能受到影响。对于后者，它需要对目标代码的进行修改，需要处理函数声明等问题，但得到的结果精度较 高，缺点是每次重新设置启动点都需要重新编译，灵活度不高，读者可以根据自己的实际需求采用有效的方式。</p>
<ul>
<li>示例详解</li>
</ul>
<p>&emsp;&emsp;该程序是一个简单的例子，文中有两处耗时的无用操作，并且二者间有一定的调用关系。</p>
<p>清单 1. 示例程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">void consumeSomeCPUTime1(int input)&#123; </div><div class="line">  int i = 0; </div><div class="line">  input++; </div><div class="line">  while(i++ &lt; 10000)&#123; </div><div class="line">    i--;  i++;  i--;  i++; </div><div class="line">  &#125; </div><div class="line"> &#125;; </div><div class="line"></div><div class="line"> void consumeSomeCPUTime2(int input)&#123; </div><div class="line">  input++; </div><div class="line">  consumeSomeCPUTime1(input); </div><div class="line">  int i = 0; </div><div class="line">  while(i++ &lt; 10000)&#123; </div><div class="line">    i--;  i++;  i--;  i++; </div><div class="line">  &#125; </div><div class="line"> &#125;; </div><div class="line"></div><div class="line"> int stupidComputing(int a, int b)&#123; </div><div class="line">  int i = 0; </div><div class="line">  while( i++ &lt; 10000)&#123;  </div><div class="line">    consumeSomeCPUTime1(i); </div><div class="line">  &#125; </div><div class="line">  int j = 0; </div><div class="line">  while(j++ &lt; 5000)&#123; </div><div class="line">    consumeSomeCPUTime2(j); </div><div class="line">  &#125; </div><div class="line">  return a+b; </div><div class="line"> &#125;; </div><div class="line"></div><div class="line"> int smartComputing(int a, int b)&#123; </div><div class="line">  return a+b; </div><div class="line"> &#125;; </div><div class="line"></div><div class="line"> void main()&#123; </div><div class="line">  int i = 0;</div><div class="line">  printf(&quot;reached the start point of performance bottle neck\n&quot;); </div><div class="line">  sleep(5);</div><div class="line">				//ProfilerStart(&quot;CPUProfile&quot;);</div><div class="line">  while( i++ &lt; 10)&#123; </div><div class="line">    printf(&quot;Stupid computing return : %d\n&quot;,stupidComputing(i, i+1)); </div><div class="line">    printf(&quot;Smart computing return %d\n&quot;,smartComputing(i+1, i+2)); </div><div class="line">  &#125;</div><div class="line">  printf(&quot;should teminate profiling now.\n&quot;);  </div><div class="line">  sleep(5);</div><div class="line">				//ProfilerStop();</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;源代码中粗体的内容（方法 1）和斜体的内容（方法 2）分别代表了上文中提及胡两种执行剖析的方式。采用方法二时将直接产生结果，采用方法 1 时需要配合 GDB 的命令来实现剖析的执行和结束，可用的方法有两种，一种是在程序运行时手动暂停函数的执行，另一种是预设断点，并在断点处执行剖析函数，两种方法（方法 a，方法 b）在命令行中的具体操作如下。<br>&emsp;&emsp;方法 a</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">gdb YOUR_PROGRAM // 启动 gdb 并选择你的程序为 gdb 的启动目标 </div><div class="line">(gdb)r // 运行 </div><div class="line">// 等待你需要的条件满足，此处示例中打印了字符 </div><div class="line">(gdb)Ctrl + c // 暂停当前函数 </div><div class="line">(gdb)p ProfilerStart(&quot;MyProfile&quot;)</div><div class="line">(gdb)c // 继续程序运行 </div><div class="line">// 等待程序打印目标模块结束，此处示例打印了提示 </div><div class="line">(gdb)Ctrl + c // 暂停当前函数 </div><div class="line">(gdb)p ProfilerStop()</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;方法 b</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">gdb YOUR_PROGRAM // 启动 gdb 并选择你的程序为 gdb 的启动目标 </div><div class="line">(gdb)b main1.c:47 // 对应于耗时模块的起始点 </div><div class="line">(gdb)b main1.c:52 // 对应于耗时模块的终止点 </div><div class="line">(gdb)r // 运行 </div><div class="line">(gdb)p ProfilerStart(&quot;MyProfile&quot;)</div><div class="line">(gdb)c // 继续程序运行 </div><div class="line">(gdb)p ProfilerStop()</div></pre></td></tr></table></figure>
<ul>
<li>结果分析</li>
</ul>
<p>&emsp;&emsp;程序执行完毕会在程序的当前工作目录下产生名为 MyProfile 的结果文件。我们可以用以下命令产生可视化的结果文档。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pprof --gv ./codeTest MyProfile</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;其中 codeTest 对应于用于测试的目标程序文件名，如果您安装了 pdf 相关的软件您还可以尝试生成 pdf 格式的结果文档，其对应的命令为 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pprof --pdf ./codeTest MyProfile &gt; MyProfile.pdf</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;转换后产生的结果文档如下图。图中的数字和框体的大小代表了的某个函数的运行时间占整个剖析时间的比例。由代码的逻辑可 知，stupidComputing，stupidComputing2 都是费时操作并且它们和 consumeSomeCPUTime 存在着一定的调用关系。</p>
<p>&emsp;&emsp;图 1. 剖析结果<br><img src="http://static.open-open.com/lib/uploadImg/20111223/20111223105703_200.gif" alt="这里写图片描述"><br>&emsp;&emsp;C/C++ 程序的性能分析工具 google-perftools</p>
<ul>
<li>结束语</li>
</ul>
<p>&emsp;&emsp;本文介绍了一个 Linux 平台上的性能剖析工具 google-perftools，并结合实例向读者展示了如何使用该工具配置、使用及分析性能瓶颈。</p>
<p>原文练级：<a href="http://www.open-open.com/lib/view/open1324609079218.html" target="_blank" rel="external">C/C++ 程序的性能分析工具 google-perftools</a><br>项目主页：<a href="http://www.open-open.com/lib/view/home/1324609079218" target="_blank" rel="external">http://www.open-open.com/lib/view/home/1324609079218</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[vim配置NERDTree，实现便捷的树形目录]]></title>
      <url>http://onesimple.cn//blog/2016/02/vim-nerdtree/</url>
      <content type="html"><![CDATA[<p>vim有很多酷炫的插件，NERDTree可以算一个。在linux下开发，很羡慕vs那样带树形目录的编辑器，怎么办？自己安装一个VIM插件NERDTree就OK了！</p>
<a id="more"></a>
<ul>
<li>下载插件</li>
</ul>
<p>git 地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/scrooloose/nerdtree.git</div></pre></td></tr></table></figure>
<p>或者下载对应的zip包，然后unzip也行，附上地址 ：<br><a href="http://download.csdn.net/detail/applebite/9652360" target="_blank" rel="external">vim配置NERDTree插件zip包</a></p>
<p>你会看到nerdtree-master的目录下有这些东东:</p>
<p><img src="https://static.oschina.net/uploads/img/201610/13085551_1LEy.png" alt="目录" title="NERDTree git或解压后的目录"></p>
<ul>
<li>配置</li>
</ul>
<p>将目录下plugin等目录里的文件依次拷到vim对应的配置中，一般在 /home/user-name/.vim/ 下， vim如果沒有plugin 等的目录，就建立一个。</p>
<p>注意，网上有人说只拷贝doc 、plugin下的文件到vim下的doc、plugin下，貌似最新的NERDTree不行，需要将lib等其他几个目录的东西都拷过去。</p>
<p>开启 Vim 后, 输入 :NERDTree 就看到了！<br><img src="https://static.oschina.net/uploads/img/201610/13090401_6g0L.png" alt="效果" title="效果"></p>
<ul>
<li>快捷键配置</li>
</ul>
<p>如果想vim打开文件时就显示树形目录怎么办？</p>
<p>在/home/user-name/.vimrc （或者在/etc/vimrc，对所有用户生效）里追加一行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">autocmd VimEnter * NERDTree</div></pre></td></tr></table></figure>
<p>想设快捷键隐藏/显示树形控件怎么办？ 追加这行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">map &lt;F2&gt; :NERDTreeToggle&lt;cr&gt;</div></pre></td></tr></table></figure></p>
<p>配置完成后，终端执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source /home/user-name/.vimrc</div></pre></td></tr></table></figure></p>
<p>让配置生效。</p>
<p>还有一些常见的快捷键：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">o    打开目录或文件</div><div class="line">回车    打开折叠  zo</div><div class="line">zc    关闭折叠</div><div class="line">zR    打开所有的折叠 (open all fold)</div><div class="line">zM    关闭所有的摺叠</div><div class="line">i    使用一个水平分割窗口来打开选中的文件. </div><div class="line">s    使用一个垂直窗口来打开选中的文件 </div><div class="line">P    转到根目录</div><div class="line">p    转到父目录</div></pre></td></tr></table></figure></p>
<p>详细其他快捷键可参考<a href="http://www.111cn.net/sys/linux/59747.htm" target="_blank" rel="external">vim 常用 NERDTree 快捷键</a></p>
<p>好了，好好享用便捷的树形目录吧！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[什么是c++中的多态]]></title>
      <url>http://onesimple.cn//blog/2015/08/polymorphism/</url>
      <content type="html"><![CDATA[<p>同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。亦所谓“一个接口，多种方法”。</p>
<a id="more"></a>
<ul>
<li><p>引言<br>多态（Polymorphism）、封装（Encapsulation）和继承（Inheritance）是面向对象思想的“三大特征”，此处俗称“<strong>面向对象的三板斧</strong>”，而多态是三板斧中最厉害的杀招，是面向对象最精微的内功，可以说，不理解多态就不懂得什么是面向对象。</p>
</li>
<li><p>定义<br>同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。<br>简单地概括为“一个接口，多种方法”。</p>
</li>
<li><p>类别<br>（1）<strong>编译时的多态性。</strong><br>&emsp;&emsp;编译时的多态性是通过<a href="http://blog.csdn.net/applebite/article/details/47205961" target="_blank" rel="external"><strong>重载</strong></a>来实现的。对于非虚的成员来说，系统在编译时，根据传递的参数、返回的类型等信息决定实现何种操作。(参考我的博文<a href="http://blog.csdn.net/applebite/article/details/47205961" target="_blank" rel="external">《c++中的函数重载》</a>)<br>（2）<strong>运行时的多态性。</strong><br>&emsp;&emsp;运行时的多态性就是指直到系统运行时，才根据实际情况决定实现何种操作。C++中，运行时的多态性通过<strong>虚成员</strong>实现。</p>
</li>
<li><p>作用<br>多态的目的则是为了<strong>接口重用</strong>。也就是说，不论传递过来的究竟是那个类的对象，函数都能够通过同一个接口调用到适应各自对象的实现方法。</p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[c++中的函数重载简析]]></title>
      <url>http://onesimple.cn//blog/2015/08/function-overloads/</url>
      <content type="html"><![CDATA[<ul>
<li>什么是函数重载<br>重载函数是函数的一种特殊情况，为方便使用，C++允许在同一范围中声明几个功能类似的同名函数，但是这些同名函数的形式参数（指<strong>参数的个数、类型或者顺序</strong>）必须不同，这组函数被称为重载函数。</li>
</ul>
<a id="more"></a>
<ul>
<li><p>函数重载的作用<br>重载函数常用来实现功能类似而所处理的数据类型不同的问题，能减少函数名的数量，提高程序的可读性。</p>
</li>
<li><p>重载函数的构成说明<br>定义一个类，添加一系列函数名相同的函数，但参数形式各有不同，测试一下能否构成重载。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">class Base</div><div class="line">&#123;</div><div class="line">	public:</div><div class="line">		void func(int a)&#123;cout &lt;&lt; &quot;this is &quot;&lt;&lt; a &lt;&lt;endl;&#125;</div><div class="line">		void func(string a)&#123;cout &lt;&lt; &quot;this is &quot; &lt;&lt; a &lt;&lt;endl;&#125;	</div><div class="line">		void func(int a,int b)&#123;cout &lt;&lt; &quot;this is &quot;&lt;&lt; a &lt;&lt;endl;&#125;</div><div class="line">		void func(int a,string b)&#123;cout &lt;&lt; &quot;this is &quot;&lt;&lt; a &lt;&lt;endl;&#125;</div><div class="line"></div><div class="line">		</div><div class="line">		//错误的重载1</div><div class="line">		int  func(int a,int b)&#123;cout &lt;&lt; &quot;this is &quot;&lt;&lt; a &lt;&lt;endl;&#125;  </div><div class="line">		//错误的重载2</div><div class="line">		void  func(const int a,int b)&#123;cout &lt;&lt; &quot;this is &quot;&lt;&lt; a &lt;&lt;endl;&#125;</div><div class="line">		//错误的重载3</div><div class="line">		void func(int b,int a)&#123;cout &lt;&lt; &quot;this is &quot;&lt;&lt; a &lt;&lt;endl;&#125;			</div><div class="line">&#125;;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	Base b;</div><div class="line">	b.func(22);</div><div class="line">	b.func(&quot;test&quot;);</div><div class="line">	</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;以上程序执行编译会报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">‘void Base::func(int)’ cannot be overloaded ...</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;即函数不能构成重载,原因分别为：</p>
<ul>
<li><p>返回值不同，不能构成函数重载。<br>对应错误1：想想也是，执行函数调用时，只知道传入的参数，是无法预知要返回什么类型的值的，所以自然不知道该调用哪一个函数。</p>
</li>
<li><p>形参是const修饰的常值不能构成函数重载。<br>对应错误2：说明编译时二者对应的符号是一致的。<br>参数是int a和 int &amp; a 不能构成重载;</p>
</li>
</ul>
<p>注意，如果形参是引用或指针是可以构成重载的。即下面的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Base</div><div class="line">&#123;</div><div class="line">	public:</div><div class="line">		void func(int &amp;a)&#123;cout &lt;&lt; &quot;this is &quot;&lt;&lt; a &lt;&lt;endl;&#125;</div><div class="line">		void func(const int &amp;a)&#123;cout &lt;&lt; &quot;this is &quot;&lt;&lt; a &lt;&lt;endl;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>参数类型相同，只是命名不同，不能构成重载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Base</div><div class="line">&#123;</div><div class="line">	public:</div><div class="line">		void func(int a)&#123;cout &lt;&lt; &quot;this is &quot;&lt;&lt; a &lt;&lt;endl;&#125;</div><div class="line">		void func(int b)&#123;cout &lt;&lt; &quot;this is &quot;&lt;&lt; b &lt;&lt;endl;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>备注</p>
</li>
</ul>
<p>&emsp;&emsp;重载是允许有多个同名的函数，这些函数的参数列表不同，即参数个数不同，或者类型不同，或者两者都不同。编译器会根据这些函数的不同列表，将同名的函数的名称做修饰，从而生成一些不同名称的预处理函数，来实现同名函数调用时的重载。</p>
<p>&emsp;&emsp;函数重载是c++比较重要的概念，涉及比较偏门的使用场景，比如参数有const修饰，就会引来比较蛋疼的疑惑，这里整理的还不够充分，后期将逐步进行整理和完善。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[“只生一个娃”--设计模式中的单例模式（Singleton）]]></title>
      <url>http://onesimple.cn//blog/2015/07/singleton/</url>
      <content type="html"><![CDATA[<center><br><img alt="封面" class="class1 class2" src="http://okqpu7sb4.bkt.clouddn.com//image/cover/design.jpg?imageView2/2/w/600"><br></center>

<p>&emsp;&emsp;<strong>所谓单例模式（Singleton），即指一个类只有一个实例（Instance），并给外界提供访问该实例的一个全局访问点。</strong></p>
<a id="more"></a>
<hr>
<ul>
<li><p>引言<br>&emsp;&emsp;被人问到什么是单例模式，突然回答不上来，似乎印象不深了。回去补了一下功课，突然明白了，原来在项目中一直使用的日志模块即采用了单例模式，只是熟视无睹，没有意识到罢了。<br>&emsp;&emsp;<strong>所谓单例模式（Singleton），即指一个类只有一个实例（Instance），并给外界提供访问该实例的一个全局访问点。</strong><br>&emsp;&emsp;通常我们可以使用全局变量的方式来实现“只生一个娃”，但更好的方法就是：<strong>让该类自身负责创建和保存它的唯一实例</strong>。这个类可以保证没有其他实例可以被创建，并且对外提供一个访问该实例的方法。下面我们看一下具体实现。</p>
</li>
<li><p>单例模式实现<br>&emsp;&emsp;定义一个Singleton类，添加一个静态方法GetInstance，负责创建自己的唯一实例，并供客户端访问。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">class Singleton  </div><div class="line">&#123;  </div><div class="line">private:  </div><div class="line">    Singleton()  </div><div class="line">    &#123;  </div><div class="line">    &#125;  </div><div class="line">    static Singleton *m_pInstance;  </div><div class="line">    </div><div class="line">public:  </div><div class="line">    static Singleton * GetInstance()  </div><div class="line">    &#123;  </div><div class="line">	    if(m_pInstance == NULL)  //若不存在，则new一个新的实例。  </div><div class="line">				m_pInstance = new Singleton();  </div><div class="line">        return m_pInstance;  </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //可以定义一个具体干活的方法</div><div class="line">    void DoWork()</div><div class="line">    &#123;</div><div class="line">		printf(&quot;the work is done!&quot;);   </div><div class="line">    &#125;  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>&emsp;&emsp;注意：<strong>构造函数设为private，这样外界就不能通过new操作符来实例化该类。</strong><br>&emsp;&emsp;客户端访问方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Singleton* p1 = Singleton :: GetInstance();</div><div class="line">Singleton* p2 = p1-&gt;GetInstance();</div><div class="line">Singleton &amp; ref = * Singleton :: GetInstance();</div><div class="line"></div><div class="line">p1-&gt;DoWork();</div><div class="line">p2-&gt;DoWork();</div><div class="line">ref.DoWork();</div><div class="line">Singleton :: GetInstance()-&gt;DoWork();</div></pre></td></tr></table></figure>
<ul>
<li>问题讨论<br>多线程环境下，如果多个线程同时访问Singleton类的GetInstance方法，则有可能造成创建多个实例。因此应该进行加锁保护，可以使用lock机制，确保当一个线程位于代码的临界区时，另一个线程如果访问可被阻塞等待，不进入临界区。可以这样来实现:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">class Singleton  </div><div class="line">&#123;  </div><div class="line">private:  </div><div class="line">    Singleton()  </div><div class="line">    &#123;  </div><div class="line">    &#125;  </div><div class="line">	static Singleton *m_pInstance;</div><div class="line">	CCriticalSection m_cs;   //定义一个临界区对象</div><div class="line">public:  </div><div class="line">    static Singleton * GetInstance()  </div><div class="line">    &#123;  </div><div class="line">        if(NULL == m_pInstance)  //若不存在，则new一个新的实例。  </div><div class="line">        &#123;</div><div class="line">			lock(m_cs)         //尽在实例未被创建时进行加锁处理</div><div class="line">	      &#123;</div><div class="line">		      if(NULL == m_pInstance) //二次判断</div><div class="line">		      &#123;</div><div class="line">		             m_pInstance = new Singleton();  </div><div class="line">		      &#125;  </div><div class="line">	      &#125;</div><div class="line">        &#125;</div><div class="line">        return m_pInstance;  </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //可以定义一个具体干活的方法</div><div class="line">    void DoWork()</div><div class="line">    &#123;</div><div class="line">		printf(&quot;the work is done!&quot;);   </div><div class="line">    &#125;  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;注意：为什么要二次判断呢？<br>&emsp;&emsp;第一次NULL == m_pInstance判断是为了避免每次都要加锁，能够提高效率；<br>&emsp;&emsp;第二次判断是因为：如果实例未被创建，两个线程同时通过第一层NULL == m_pInstance判断，由于lock机制，只有第一个线程进入，另一个排队等候，如果第一个线程创建了实例并出来后，第二个线程进入后还是可以创建新的实例的。</p>
<p>&emsp;&emsp;由此可见：想要保证只生一个小孩真是要时时留意、处处留心，安全措施要绝对保证啊 O(∩_∩)O.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[windows平台多线程同步之Mutex的应用]]></title>
      <url>http://onesimple.cn//blog/2015/07/mutex-on-windows-platform/</url>
      <content type="html"><![CDATA[<ul>
<li><strong>前言</strong><br><strong>线程组成</strong>：</li>
</ul>
<ol>
<li>线程的内核对象，操作系统用来管理该线程的数据结构。</li>
<li>线程堆栈，它用于维护线程在执行代码时需要的所有参数和局部变量。</li>
</ol>
<a id="more"></a>
<p>&emsp;&emsp;操作系统为每一个运行线程安排一定的CPU时间 —— <strong>时间片</strong>。系统通过一种循环的方式为线程提供时间片，线程在自己的时间内运行，多个线程不断地切换运行，因时间片相当短，因此，给用户的感觉，就好像线程是同时运行的一样。<br>&emsp;&emsp;单cpu计算机一个时间只能运行一个线程，如果计算机拥有多个CPU，线程就能真正意义上同时运行了。<br>&emsp;&emsp;windows平台下，创建线程可以使用windows api 函数CreateThread来实现,函数声明是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">WINBASEAPI</div><div class="line">HANDLE</div><div class="line">WINAPI</div><div class="line">CreateThread(</div><div class="line">    LPSECURITY_ATTRIBUTES lpThreadAttributes,</div><div class="line">    DWORD dwStackSize,</div><div class="line">    LPTHREAD_START_ROUTINE lpStartAddress,</div><div class="line">    LPVOID lpParameter,</div><div class="line">    DWORD dwCreationFlags,</div><div class="line">    LPDWORD lpThreadId</div><div class="line">    );</div></pre></td></tr></table></figure>
<p>参数说明：</p>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">lpThreadAttributes</td>
<td style="text-align:center">线程安全性，使用缺省安全性,一般缺省null</td>
</tr>
<tr>
<td style="text-align:center">dwStackSize</td>
<td style="text-align:center">堆栈大小，0为缺省大小</td>
</tr>
<tr>
<td style="text-align:center">lpStartAddress</td>
<td style="text-align:center">线程要执行的函数指针，即入口函数</td>
</tr>
<tr>
<td style="text-align:center">lpParameter</td>
<td style="text-align:center">线程参数</td>
</tr>
<tr>
<td style="text-align:center">dwCreationFlags</td>
<td style="text-align:center">线程标记，如为0，则创建后立即运行</td>
</tr>
<tr>
<td style="text-align:center">lpThreadId</td>
<td style="text-align:center">LPDWORD为返回值类型，一般传递地址去接收线程的标识符，一般设为null</td>
</tr>
</tbody>
</table>
<p>因为要使用windows api函数,所以包含：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#include &lt;windows.h&gt;</div></pre></td></tr></table></figure></p>
<p>另外需要标准输入输出函数，所以包含：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream.h&gt;</div></pre></td></tr></table></figure>
<ul>
<li>问题引出<br>&emsp;&emsp;以多个售票窗口卖同一张火车票为例，定义一个全局的票数tickets，用两个线程来执行卖票，两个线程访问同一个变量tickets，先看一个不正确的写法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">//问题程序</div><div class="line"></div><div class="line">#include &lt;windows.h&gt;</div><div class="line">#include &lt;iostream.h&gt;</div><div class="line"></div><div class="line">DWORD WINAPI Fun1Proc(</div><div class="line">  LPVOID lpParameter   </div><div class="line">);</div><div class="line"></div><div class="line">DWORD WINAPI Fun2Proc(</div><div class="line">  LPVOID lpParameter   </div><div class="line">);</div><div class="line"></div><div class="line"></div><div class="line">int tickets=100;</div><div class="line"></div><div class="line">void main()</div><div class="line">&#123;</div><div class="line">	HANDLE hThread1;</div><div class="line">	HANDLE hThread2;</div><div class="line">	hThread1=CreateThread(NULL,0,Fun1Proc,NULL,0,NULL);</div><div class="line">	hThread2=CreateThread(NULL,0,Fun2Proc,NULL,0,NULL);</div><div class="line">	</div><div class="line">	CloseHandle(hThread1);</div><div class="line">	CloseHandle(hThread2);</div><div class="line"></div><div class="line">	system(&quot;pause&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">DWORD WINAPI Fun1Proc(</div><div class="line">  LPVOID lpParameter   </div><div class="line">)</div><div class="line">&#123;</div><div class="line">	while(TRUE)</div><div class="line">	&#123;</div><div class="line">		if(tickets&gt;0)</div><div class="line">		&#123;</div><div class="line">			Sleep(1);//假定为卖票需要花费的时间</div><div class="line">			cout&lt;&lt;&quot;thread1 sell ticket : &quot;&lt;&lt;tickets--&lt;&lt;endl;</div><div class="line">		&#125;</div><div class="line">		else</div><div class="line">			break;	</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">DWORD WINAPI Fun2Proc(</div><div class="line">  LPVOID lpParameter   // thread data</div><div class="line">)</div><div class="line">&#123;	</div><div class="line">	while(TRUE)</div><div class="line">	&#123;</div><div class="line">		if(tickets&gt;0)</div><div class="line">		&#123;</div><div class="line">			Sleep(1);</div><div class="line">			cout&lt;&lt;&quot;thread2 sell ticket : &quot;&lt;&lt;tickets--&lt;&lt;endl;</div><div class="line">		&#125;</div><div class="line">		else</div><div class="line">			break;	</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;线程中sleep(1);表名该线程放弃执行的权利，操作系统会选择另外的线程进行执行。所以执行结果是：</p>
<p><center><div style="text-align: center"><br><img src="http://img.blog.csdn.net/20150712160039526" style="display:inline"></div></center></p>
<p></p><p>执行结果</p><br><br><br>&emsp;&emsp;可以看见程序不是按照预期的效果执行的，tickets的改变是混乱的。所以两个线程访问同一块资源时，需要考虑<strong>线程同步</strong>问题，即其中一个线程操作改资源时，其他线程不能访问该资源，只能等待，该线程执行结束之后，其他线程才能对该资源进行访问。<br>&emsp;&emsp;一般采用<strong>互斥对象</strong>来实现线程的同步。<p></p>
<ul>
<li><strong>互斥对象</strong><br><strong>特征</strong>：<br>&emsp;&emsp;互斥对象(mutex)属于内核对象，它能够确保线程拥有对单个资源的互斥访问权。<br>&emsp;&emsp;互斥对象包含一个使用数量，一个线程ID和一个计数器。<br>&emsp;&emsp;ID用于标识系统中的哪个线程当前拥有互斥对象，计数器用于指明该线程拥有互斥对象的次数。<br>&emsp;&emsp;采用互斥对象进行多线程同步的正确例子如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">#include &lt;windows.h&gt;</div><div class="line">#include &lt;iostream.h&gt;</div><div class="line"></div><div class="line">DWORD WINAPI Fun1Proc(</div><div class="line">  LPVOID lpParameter   // thread data</div><div class="line">);</div><div class="line"></div><div class="line">DWORD WINAPI Fun2Proc(</div><div class="line">  LPVOID lpParameter   // thread data</div><div class="line">);</div><div class="line">int index=0;</div><div class="line">int tickets=100;</div><div class="line">HANDLE hMutex;</div><div class="line">void main()</div><div class="line">&#123;</div><div class="line">	HANDLE hThread1;</div><div class="line">	HANDLE hThread2;</div><div class="line">	hThread1=CreateThread(NULL,0,Fun1Proc,NULL,0,NULL);</div><div class="line">	hThread2=CreateThread(NULL,0,Fun2Proc,NULL,0,NULL);</div><div class="line">	CloseHandle(hThread1);</div><div class="line">	CloseHandle(hThread2);</div><div class="line"></div><div class="line">	//创建一个匿名的互斥对象，且为有信号状态，</div><div class="line">	hMutex=CreateMutex(NULL,FALSE,NULL);</div><div class="line"></div><div class="line">	system(&quot;pause&quot;);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">DWORD WINAPI Fun1Proc(</div><div class="line">  LPVOID lpParameter   // thread data</div><div class="line">)</div><div class="line">&#123;</div><div class="line">	while(TRUE)</div><div class="line">	&#123;</div><div class="line">		//等待互斥对象的信号，INFINITE表示一直等待,对之后的代码进行保护</div><div class="line">		WaitForSingleObject(hMutex,INFINITE);</div><div class="line">		if(tickets&gt;0)</div><div class="line">		&#123;</div><div class="line">			Sleep(1);</div><div class="line">			cout&lt;&lt;&quot;thread1 sell ticket : &quot;&lt;&lt;tickets--&lt;&lt;endl;</div><div class="line">		&#125;</div><div class="line">		else</div><div class="line">			break;</div><div class="line">		//释放指定互斥对象的所有权，操作系统将互斥对象的线程id被置为0，互斥对象变为已通知状态，线程2就能请求到互斥对象</div><div class="line">		ReleaseMutex(hMutex);</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">DWORD WINAPI Fun2Proc(</div><div class="line">  LPVOID lpParameter   // thread data</div><div class="line">)</div><div class="line">&#123;</div><div class="line">	while(TRUE)</div><div class="line">	&#123;</div><div class="line">		WaitForSingleObject(hMutex,INFINITE);</div><div class="line">		if(tickets&gt;0)</div><div class="line">		&#123;</div><div class="line">			Sleep(1);</div><div class="line">			cout&lt;&lt;&quot;thread2 sell ticket : &quot;&lt;&lt;tickets--&lt;&lt;endl;</div><div class="line">		&#125;</div><div class="line">		else</div><div class="line">			break;</div><div class="line">		ReleaseMutex(hMutex);</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><center><div style="text-align: center"><br><img src="http://img.blog.csdn.net/20150712163552397" style="display:inline"></div></center></p>
<p></p><p>执行结果</p><br><br><br>&emsp;&emsp;通过测试可知，以上互斥对象的引入可以很好的解决线程间访问资源同步的问题。关于互斥对象，还有以下几个问题需要说明。<p></p>
<ul>
<li>互斥对象的释放问题<br>&emsp;&emsp;如果main中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hMutex=CreateMutex(NULL,TRUE,NULL);</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;子线程中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">while(TRUE)</div><div class="line">&#123;</div><div class="line">	ReleaseMutex(hMutex);//无效</div><div class="line">	//等待互斥对象的信号，INFINITE表示一直等待,对之后的代码进行保护</div><div class="line">	WaitForSingleObject(hMutex,INFINITE);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果CreateMutex第二个参数为true，则表示主线程拥有该互斥对象，操作系统将互斥对象的线程id设为主线程的线程id，如果主线程不释放，则子线程会一直等待，此时子线程也没有权利进行释放，<strong>所以使用互斥对象的原则是：谁拥有互斥对象，谁释放互斥对象。</strong></p>
<p>&emsp;&emsp;另外，如果main中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hMutex=CreateMutex(NULL,TRUE,NULL);</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;并且再次请求互斥对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">WaitForSingleObject(hMutex,INFINITE);</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;并调用一次释放互斥对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ReleaseMutex(hMutex);</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;此时子线程依然是等待状态，得不到互斥对象的使用权，原因是：<br>&emsp;&emsp;CreateMutex(NULL,TRUE,NULL)由于第二个参数为true，主线程拥有互斥对象的使用权，互斥对象内部计数器加1，再次调用WaitForSingleObject请求互斥对象时，<strong>内部计数器</strong>又加1，计数器是记录线程拥有互斥对象的次数，而只释放ReleaseMutex了一次，互斥对象依然被占用，所以子线程得不到使用权。<br>&emsp;&emsp;因此正确的写法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">hMutex=CreateMutex(NULL,TRUE,NULL);</div><div class="line">WaitForSingleObject(hMutex,INFINITE);</div><div class="line">ReleaseMutex(hMutex);</div><div class="line">ReleaseMutex(hMutex);</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果多次请求互斥对象，就应该多次释放互斥对象。</p>
<p>&emsp;&emsp;再看这样一种情况，线程中没有释放互斥对象的拥有权：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">DWORD WINAPI Fun1Proc(LPVOID lpParameter)</div><div class="line">&#123;</div><div class="line">	waitforsingleobject(hmutex,infinite);</div><div class="line">	cout&lt;&lt;&quot;thread1 is running&quot;&lt;&lt;endl;</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line">DWORD WINAPI Fun2Proc(LPVOID lpParameter)</div><div class="line">&#123;</div><div class="line">	waitforsingleobject(hmutex,infinite);</div><div class="line">	cout&lt;&lt;&quot;thread2 is running&quot;&lt;&lt;endl;</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;此时执行依然能够得到输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&quot;thread1 is running</div><div class="line">&quot;thread2 is running</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;这是因为：如果线程退出时没有释放互斥对象，操作系统在销毁线程时会自动将线程占用的互斥对象的信息清除，计数器归零，这样其他线程（thread2 ）就能申请到互斥对象使用权。</p>
<ul>
<li>创建命名互斥对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">hMutex=CreateMutex(NULL,TRUE,&quot;myApp&quot;);</div><div class="line">if(hMutex)</div><div class="line">&#123;</div><div class="line">	if(ERROR_ALREADY_EXISTS==GetLastError())</div><div class="line">	&#123;</div><div class="line">		cout&lt;&lt;&quot;已经有一个相同应用程序在运行!&quot;&lt;&lt;endl;</div><div class="line">		return;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;命名互斥对象的一种应用是：通过命名互斥对象，可以保证当前只有一个应用程序实例在运行。</p>
<p>&emsp;&emsp;以上是关于windows平台下多线程同步相关的互斥对象的使用问题，之后将对线程同步的<strong>事件对象Event</strong>进行介绍和解析，敬请关注。文中如有谬误，还望不吝赐教。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[windows平台多线程同步之Event的应用]]></title>
      <url>http://onesimple.cn//blog/2015/07/event-on-windows-platform/</url>
      <content type="html"><![CDATA[<ul>
<li><strong>前言</strong><br><strong>线程组成</strong>：</li>
</ul>
<ol>
<li>线程的内核对象，操作系统用来管理该线程的数据结构。</li>
<li>线程堆栈，它用于维护线程在执行代码时需要的所有参数和局部变量。</li>
</ol>
<a id="more"></a>
<p>&emsp;&emsp;操作系统为每一个运行线程安排一定的CPU时间 —— <strong>时间片</strong>。系统通过一种循环的方式为线程提供时间片，线程在自己的时间内运行，多个线程不断地切换运行，因时间片相当短，因此，给用户的感觉，就好像线程是同时运行的一样。<br>&emsp;&emsp;单cpu计算机一个时间只能运行一个线程，如果计算机拥有多个CPU，线程就能真正意义上同时运行了。<br>&emsp;&emsp;windows平台下，创建线程可以使用windows api 函数CreateThread来实现,函数声明是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">WINBASEAPI</div><div class="line">HANDLE</div><div class="line">WINAPI</div><div class="line">CreateThread(</div><div class="line">    LPSECURITY_ATTRIBUTES lpThreadAttributes,</div><div class="line">    DWORD dwStackSize,</div><div class="line">    LPTHREAD_START_ROUTINE lpStartAddress,</div><div class="line">    LPVOID lpParameter,</div><div class="line">    DWORD dwCreationFlags,</div><div class="line">    LPDWORD lpThreadId</div><div class="line">    );</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;参数说明：</p>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">lpThreadAttributes</td>
<td style="text-align:center">线程安全性，使用缺省安全性,一般缺省null</td>
</tr>
<tr>
<td style="text-align:center">dwStackSize</td>
<td style="text-align:center">堆栈大小，0为缺省大小</td>
</tr>
<tr>
<td style="text-align:center">lpStartAddress</td>
<td style="text-align:center">线程要执行的函数指针，即入口函数</td>
</tr>
<tr>
<td style="text-align:center">lpParameter</td>
<td style="text-align:center">线程参数</td>
</tr>
<tr>
<td style="text-align:center">dwCreationFlags</td>
<td style="text-align:center">线程标记，如为0，则创建后立即运行</td>
</tr>
<tr>
<td style="text-align:center">lpThreadId</td>
<td style="text-align:center">LPDWORD为返回值类型，一般传递地址去接收线程的标识符，一般设为null</td>
</tr>
</tbody>
</table>
<p>&emsp;&emsp;因为要使用windows api函数,所以包含：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#include &lt;windows.h&gt;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;另外需要标准输入输出函数，所以包含：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream.h&gt;</div></pre></td></tr></table></figure></p>
<ul>
<li><strong>问题引出</strong></li>
</ul>
<p>&emsp;&emsp;以多个售票窗口卖同一张火车票为例，定义一个全局的票数tickets，用两个线程来执行卖票，两个线程访问同一个变量tickets，先看一个不正确的写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">//问题程序</div><div class="line">#include &lt;windows.h&gt;</div><div class="line">#include &lt;iostream.h&gt;</div><div class="line">DWORD WINAPI Fun1Proc(</div><div class="line">  LPVOID lpParameter</div><div class="line">);</div><div class="line">DWORD WINAPI Fun2Proc(</div><div class="line">  LPVOID lpParameter</div><div class="line">);</div><div class="line">int tickets=100;</div><div class="line">void main()</div><div class="line">&#123;</div><div class="line"> HANDLE hThread1;</div><div class="line"> HANDLE hThread2;</div><div class="line"> hThread1=CreateThread(NULL,0,Fun1Proc,NULL,0,NULL);</div><div class="line"> hThread2=CreateThread(NULL,0,Fun2Proc,NULL,0,NULL);</div><div class="line"> </div><div class="line"> CloseHandle(hThread1);</div><div class="line"> CloseHandle(hThread2);</div><div class="line"> system(&quot;pause&quot;);</div><div class="line">&#125;</div><div class="line">DWORD WINAPI Fun1Proc(</div><div class="line">  LPVOID lpParameter</div><div class="line">)</div><div class="line">&#123;</div><div class="line"> while(TRUE)</div><div class="line"> &#123;</div><div class="line">  if(tickets&gt;0)</div><div class="line">  &#123;</div><div class="line">   Sleep(1);//假定为卖票需要花费的时间</div><div class="line">   cout&lt;&lt;&quot;thread1 sell ticket : &quot;&lt;&lt;tickets--&lt;&lt;endl;</div><div class="line">  &#125;</div><div class="line">  else</div><div class="line">   break;</div><div class="line"> &#125;</div><div class="line"> return 0;</div><div class="line">&#125;</div><div class="line">DWORD WINAPI Fun2Proc(</div><div class="line">  LPVOID lpParameter // thread data</div><div class="line">)</div><div class="line">&#123;</div><div class="line"> while(TRUE)</div><div class="line"> &#123;</div><div class="line">  if(tickets&gt;0)</div><div class="line">  &#123;</div><div class="line">   Sleep(1);</div><div class="line">   cout&lt;&lt;&quot;thread2 sell ticket : &quot;&lt;&lt;tickets--&lt;&lt;endl;</div><div class="line">  &#125;</div><div class="line">  else</div><div class="line">   break;</div><div class="line"> &#125;</div><div class="line"> return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;线程中sleep(1);表名该线程放弃执行的权利，操作系统会选择另外的线程进行执行。所以执行结果是：</p>
<p><center>![Alt test]<div style="text-align: center"><br><img src="http://img.blog.csdn.net/20150712160039526" style="display:inline"></div></center></p>
<p></p><p>执行结果</p><br><br><br>&emsp;&emsp;可以看见程序不是按照预期的效果执行的，tickets的改变是混乱的。所以两个线程访问同一块资源时，需要考虑<strong>线程同步</strong>问题，即其中一个线程操作改资源时，其他线程不能访问该资源，只能等待，该线程执行结束之后，其他线程才能对该资源进行访问。<br>&emsp;&emsp;一般采用<strong>互斥对象</strong>、<strong>事件对象</strong>、<strong>关键代码段等</strong>来实现线程的同步。可参考我的另一篇博文<a href="http://blog.csdn.net/applebite/article/details/46852149" target="_blank" rel="external"> windows平台多线程同步之Mutex的应用</a>.本节介绍的是事件对象的使用。<p></p>
<ul>
<li><strong>事件对象</strong><br><strong>特征</strong>：<br>&emsp;&emsp;事件对象也属于内核对象，包含一个使用计数，一个用于指明该事件是一个自动重置的事件还是一个人工重置的事件的布尔值，另一个用于指明该事件处于已通知状态还是未通知状态的布尔值。<br>&emsp;&emsp;有两种不同类型的事件对象。一种是人工重置的事件，另一种是自动重置的事件。<br>&emsp;&emsp;当人工重置的事件得到通知时，等待该事件的所有线程均变为可调度线程。当一个自动重置的事件得到通知时，等待该事件的线程中只有一个线程变为可调度线程。<br>&emsp;&emsp;创建事件对象，可以使用api函数CreateEvent,具体声明如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">WINBASEAPI</div><div class="line">HANDLE</div><div class="line">WINAPI</div><div class="line">CreateEvent(</div><div class="line">    LPSECURITY_ATTRIBUTES lpEventAttributes,</div><div class="line">    BOOL bManualReset,</div><div class="line">    BOOL bInitialState,</div><div class="line">    LPCWSTR lpName</div><div class="line">    );</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;参数说明：</p>
<table class="table table-bordered table-striped table-condensed"><br>    <tr><br>        <td>lpEventAttributes</td><br>  <td>安全性，采用null默认安全性。</td><br>    </tr><br>    <tr><br>        <td>bManualReset</td><br>  <td>（TRUE）人工重置或（FALSE）自动重置事件对象为非信号状态，若设为人工重置，则当事件为有信号状态时，所有等待的线程都变为可调度线程。</td><br>    </tr><br>        <tr><br>        <td>bInitialState</td><br>  <td>指定事件对象的初始化状态，TRUE：初始为有信号状态。</td><br>    </tr><br>        <tr><br>        <td>lpName </td><br>  <td>事件对象的名字，一般null匿名即可。</td><br>    </tr><br></table>

<p>&emsp;&emsp;新建一个win32控制台工程。创建一个全局的事件句柄对象，保存创建的事件的句柄。先看这样一个有问题的写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">#include &lt;windows.h&gt;</div><div class="line">#include &lt;iostream.h&gt;</div><div class="line"></div><div class="line">DWORD WINAPI Fun1Proc(LPVOID lpParameter   );</div><div class="line"></div><div class="line">DWORD WINAPI Fun2Proc(LPVOID lpParameter  );</div><div class="line"></div><div class="line">int tickets=100;</div><div class="line">HANDLE g_hEvent;</div><div class="line"></div><div class="line">void main()</div><div class="line">&#123;</div><div class="line">	HANDLE hThread1;</div><div class="line">	HANDLE hThread2;</div><div class="line">	hThread1=CreateThread(NULL,0,Fun1Proc,NULL,0,NULL);</div><div class="line">	hThread2=CreateThread(NULL,0,Fun2Proc,NULL,0,NULL);</div><div class="line">	CloseHandle(hThread1);</div><div class="line">	CloseHandle(hThread2);</div><div class="line"></div><div class="line">	g_hEvent=CreateEvent(NULL,TRUE,FALSE,&quot;tickets&quot;);</div><div class="line"></div><div class="line">	system(&quot;pause&quot;);</div><div class="line">	CloseHandle(g_hEvent);</div><div class="line">&#125;</div><div class="line"></div><div class="line">DWORD WINAPI Fun1Proc(LPVOID lpParameter )</div><div class="line">&#123;</div><div class="line">	while(TRUE)</div><div class="line">	&#123;</div><div class="line">		WaitForSingleObject(g_hEvent,INFINITE);</div><div class="line">		ResetEvent(g_hEvent);</div><div class="line">		if(tickets&gt;0)</div><div class="line">		&#123;</div><div class="line">			Sleep(1);</div><div class="line">			cout&lt;&lt;&quot;thread1 sell ticket : &quot;&lt;&lt;tickets--&lt;&lt;endl;</div><div class="line">		&#125;</div><div class="line">		else</div><div class="line">			break;</div><div class="line">		SetEvent(g_hEvent);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">DWORD WINAPI Fun2Proc(LPVOID lpParameter)</div><div class="line">&#123;</div><div class="line">	</div><div class="line">	while(TRUE)</div><div class="line">	&#123;</div><div class="line">		WaitForSingleObject(g_hEvent,INFINITE);</div><div class="line">		ResetEvent(g_hEvent);</div><div class="line">		if(tickets&gt;0)</div><div class="line">		&#123;</div><div class="line">			Sleep(1);</div><div class="line">			cout&lt;&lt;&quot;thread2 sell ticket : &quot;&lt;&lt;tickets--&lt;&lt;endl;</div><div class="line">		&#125;</div><div class="line">		else</div><div class="line">			break;</div><div class="line">		SetEvent(g_hEvent);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;初始化中将时间设为手动重置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g_hEvent=CreateEvent(NULL,TRUE,FALSE,&quot;tickets&quot;);</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;具体思路是：其中一个线程等待到信号之后，重置事件，进行数据处理，处理完成之后再次触发事件。另一个线程收到新的信号，同样处理并重置事件。先来看看执行结果：</p>
<p><center><div style="text-align: center"><br><img src="http://img.blog.csdn.net/20150712230456631" style="display:inline"></div></center></p>
<p></p><p>执行结果</p><br><br><br>&emsp;&emsp;通过查看结果可知没能实现线程的同步，因为线程1 WaitForSingleObject等待到事件有信号时，该线程被分配的时间片可能已经用完，此时操作系统执行线程2，正好事件还是有信号状态，所以线程2直接往下执行，导致了读写的混乱。<br>&emsp;&emsp;如果移植到多cpu平台，线程1和线程2可以同时运行，此时处理的结果就更加不可预料，所以这种同步手段不可用。<br>&emsp;&emsp;故采用初始化时设置事件对象为自动重置的对象，并触发为有信号，等待该事件的线程只会有一个是有信号状态，该线程执行结束，设置该事件对象为有信号状态，则另外的一个线程可以变为有信号状态。实现代码变为如下：<br>初始化中将事件设为手动触发且无信号状态，之后触发信号：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">g_hEvent=CreateEvent(NULL,FALSE,FALSE,NULL);</div><div class="line">SetEvent(g_hEvent);</div></pre></td></tr></table></figure><p></p>
<p> &emsp;&emsp;线程中请求到该事件信号，自动将事件置为无信号状态，线程按cpu分配的时间片去执行，等到执行完毕，将事件信号触发为有信号状态，另一个线程此时请求到该信号，进行同样的执行。线程while循环为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">while(TRUE)</div><div class="line">&#123;</div><div class="line">	WaitForSingleObject(g_hEvent,INFINITE);//收到信号，自动重置</div><div class="line">	if(tickets&gt;0)</div><div class="line">	&#123;</div><div class="line">		Sleep(1);</div><div class="line">		cout&lt;&lt;&quot;thread1 sell ticket : &quot;&lt;&lt;tickets--&lt;&lt;endl;</div><div class="line">	&#125;</div><div class="line">	else</div><div class="line">		break;</div><div class="line">	SetEvent(g_hEvent);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;与<a href="http://blog.csdn.net/applebite/article/details/46852149" target="_blank" rel="external">mutex对象</a>.不同的是,设为人工重置的事件对象，如果重复SetEvent()设为有信号状态，若想重置只需要执行一次ResetEvent()即可。</p>
<ul>
<li><strong>创建命名事件对象</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">	g_hEvent=CreateEvent(NULL,TRUE,FALSE,&quot;tickets&quot;);</div><div class="line">if(g_hEvent)</div><div class="line">&#123;</div><div class="line">	if(ERROR_ALREADY_EXISTS==GetLastError())</div><div class="line">	&#123;</div><div class="line">		cout&lt;&lt;&quot;only instance can run!&quot;&lt;&lt;endl;</div><div class="line">		return;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>&emsp;&emsp;命名事件对象的一种应用是：通过命名事件对象，可以保证当前只有一个应用程序实例在运行。<br>&emsp;&emsp;以上是关于windows平台下多线程同步相关的事件对象的使用问题，之后将对线程同步的<strong>关键代码段</strong>进行介绍和解析，敬请关注。文中如有谬误，还望不吝赐教。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[智能指针的实现机理]]></title>
      <url>http://onesimple.cn//blog/2015/07/principles-of-auto-pointer/</url>
      <content type="html"><![CDATA[<p>&emsp;&emsp;智能指针(smart pointer)是存储指向动态分配（堆）对象指针的类，用于生存期控制，能够确保自动正确的销毁动态分配的对象，防止内存泄露。它的一种通用实现技术是使用引用计数(reference count)，实现指针指向的对象的共享的。</p>
<a id="more"></a>
<ul>
<li>介绍</li>
</ul>
<p>其实现的基本思想：</p>
<p>&emsp;&emsp;1.每次创建类的新对象时，初始化指针并将<strong>引用计数</strong>置为1；<br>&emsp;&emsp;2.当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数；<br>&emsp;&emsp;3.对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数减至0，则删除对象），并增加右操作数所指对象的引用计数；<br>&emsp;&emsp;4.调用析构函数时，减少引用计数（如果引用计数减至0，则删除基础对象）；<br>&emsp;&emsp;4.重载“-&gt;”以及“*”操作符，使得智能指针有类似于普通指针的操作。<br>&emsp;&emsp;根据以上分析，首先可以得出下面的类模板原型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">template &lt;class T&gt;</div><div class="line">class SmartPointer</div><div class="line">&#123;</div><div class="line">public:</div><div class="line"></div><div class="line">	SmartPointer(T *p = 0);//构造函数</div><div class="line">	SmartPointer(const SmartPointer&amp; src);//拷贝构造函数</div><div class="line">	SmartPointer&amp; operator = (const SmartPointer&amp; rhs);//赋值函数</div><div class="line"></div><div class="line">	T* operator -&gt; ();//重载-&gt;</div><div class="line">	T&amp; operator * ();//重载*</div><div class="line">	~SmartPointer();//析构函数</div><div class="line"></div><div class="line">private:</div><div class="line"></div><div class="line">	void MinusRef()</div><div class="line">	&#123;</div><div class="line">		//被其他成员函数所调用</div><div class="line">		if (--*m_pRef == 0)//自身的引用计数减1</div><div class="line">		&#123;</div><div class="line">			//如果计数为0，则释放内存</div><div class="line">			delete m_ptr;</div><div class="line"></div><div class="line">			delete m_pRef;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	T *m_ptr;							//保存对象指针</div><div class="line">	size_t *m_pRef;						//保存引用计数</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;上面的私有成员函数MinusRef将引用计数减1。如果引用计数减至0，则删除m_ptr所指对象。根据前面的分析，MinusRef只被赋值函数以及析构函数使用。<br>下面说明各个成员的具体定义。<br>&emsp;&emsp;首先是构造函数与析构函数的定义。普通构造函数中，m_ptr与p指向同一块内存，并初始化引用计数为1。拷贝构造函数中与普通构造函数的不同之处为引用计数需要加1。析构函数调用私有成员MinusRef对引用计数递减，并且判断是否需要释放对象。代码如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">template&lt;class T&gt;</div><div class="line">SmartPointer&lt;T&gt;::SmartPointer(T *p)		//普通构造函数</div><div class="line">&#123;</div><div class="line">	m_ptr = p;							//m_ptr与p指向同一内存</div><div class="line">	m_pRef = new size_t(1);				//m_pRef初值为1</div><div class="line">&#125;</div><div class="line"></div><div class="line">template&lt;class T&gt;</div><div class="line">SmartPointer&lt;T&gt;::SmartPointer(const SmartPointer&lt;T&gt;&amp; src)//拷贝构造函数</div><div class="line">&#123;</div><div class="line">	m_ptr = src.m_ptr;		//m_ptr与src.m_ptr指向同一内存</div><div class="line">	m_pRef++;</div><div class="line">	m_pRef = src.m_pRef;	//拷贝引用计数</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">template&lt;class T&gt;</div><div class="line">SmartPointer&lt;T&gt;::~SmartPointer()		//析构函数</div><div class="line">&#123;</div><div class="line">	MinusRef();				//引用减1,如果减后的引用为0，则释放内存</div><div class="line">	std::cout&lt;&lt;&quot;SmartPointer: Destructor&quot;&lt;&lt;std::endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;接下来是“-&gt;”和“*”的重载。这两个函数很简单，只需要分别返回m_ptr以及m_ptr所指的内容即可。注意，如果m_ptr此时为空，则应该抛出异常。代码如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">template&lt;class T&gt;</div><div class="line">T* SmartPointer&lt;T&gt;::operator -&gt; ()	//重载 -&gt;</div><div class="line">&#123;</div><div class="line">	if (m_ptr)</div><div class="line">		return m_ptr;</div><div class="line"></div><div class="line">	//m_ptr为NULL时，抛出异常</div><div class="line"></div><div class="line">	throw std::runtime_error(&quot;access through NULL pointer&quot;);</div><div class="line">&#125;</div><div class="line">template&lt;class T&gt;</div><div class="line">T&amp; SmartPointer&lt;T&gt;::operator * () //重载 *</div><div class="line">&#123;</div><div class="line">	if (m_ptr)</div><div class="line">		return *m_ptr;</div><div class="line">	//m_ptr为NULL时，抛出异常</div><div class="line"></div><div class="line">	throw std::runtime_error(&quot;dereference of NULL pointer&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;最后是赋值函数的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">template&lt;class T&gt;</div><div class="line"></div><div class="line">SmartPointer&lt;T&gt;&amp; SmartPointer&lt;T&gt;::operator = (const SmartPointer&lt;T&gt;&amp; rhs)//赋值函数</div><div class="line">&#123;</div><div class="line">	++*rhs.m_pRef;		//rhs的引用加1</div><div class="line">	MinusRef();			//自身指向的原指针的引用减1</div><div class="line">	m_ptr = rhs.m_ptr;	//m_ptr合rhs.m_ptr指向同一个对象</div><div class="line">	m_pRef = rhs.m_pRef; //复制引用</div><div class="line">	return *this;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;这样，就可以像 std::auto_ptr那样来使用SmartPointer。以下先定义一个测试类，测试程序如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">class Test</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	Test() &#123;name = NULL;&#125;</div><div class="line">	Test(const char* strname)//构造函数</div><div class="line">	&#123;</div><div class="line">		name = new char[strlen(strname)+1];//分配内存</div><div class="line">		strcpy(name, strname);//拷贝字符串</div><div class="line">	&#125;</div><div class="line">	Test&amp; operator = (const char *namestr)//赋值函数</div><div class="line">	&#123;</div><div class="line">		if (name != NULL)</div><div class="line">		&#123;</div><div class="line">			delete name;//释放原来的内存</div><div class="line">		&#125;</div><div class="line">		name = new char[strlen(namestr)+1];//分配新内存</div><div class="line">		strcpy(name, namestr);//拷贝字符串</div><div class="line">		return *this;</div><div class="line">	&#125;</div><div class="line">	void ShowName() &#123;cout &lt;&lt; name &lt;&lt; endl;&#125;</div><div class="line">	~Test()</div><div class="line">	&#123;</div><div class="line">		if (name != NULL)</div><div class="line">		&#123;</div><div class="line">			delete name;</div><div class="line">		&#125;</div><div class="line">		name = NULL;</div><div class="line">		cout &lt;&lt; &quot;delete name&quot; &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line">public:</div><div class="line">	char *name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">int _tmain(int argc, _TCHAR* argv[])</div><div class="line">&#123;</div><div class="line">	SmartPointer&lt;Test&gt; t1;//空指针</div><div class="line">	SmartPointer&lt;Test&gt; t2(new Test(&quot;fefd&quot;));</div><div class="line">	SmartPointer&lt;Test&gt; t3(new Test(&quot;wewew&quot;));</div><div class="line">	try</div><div class="line">	&#123;</div><div class="line">		t1-&gt;ShowName();//空指针调用抛出异常</div><div class="line">	&#125;</div><div class="line">	catch (const exception&amp; err)</div><div class="line">	&#123;</div><div class="line">		cout &lt;&lt; err.what() &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	t2-&gt;ShowName();		//使用t2调用showName()</div><div class="line">	*t2 = &quot;David&quot;;		//使用t2给对象赋值</div><div class="line">	t2-&gt;ShowName();		//使用t2调用showName()</div><div class="line">	t2 = t3;			//赋值，原来t2的对象引用为0，发生析构</div><div class="line">						//而t3的对象引用加1</div><div class="line">	cout &lt;&lt; &quot;End of main...&quot; &lt;&lt; endl;</div><div class="line"></div><div class="line">	getchar();</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;main函数代码第41行，t1指向一个NULL指针，因此调用ShowName时会出现异常（异常在重载的“-&gt;”函数中被抛出）。<br>&emsp;&emsp;main函数代码第48～50行，使用SmartPtr对象对Test对象进行操作，其方法与使用Test对象指针的操作方法相同。<br>&emsp;&emsp;main函数代码第51行，对t2进行赋值操作，操作完成后，t2引用的原对象发生析构（此对象没有SmartPtr对象引用了），t2和t3引用同一个对象，于是这个对象的引用计数加1。注意，这里我们并没有显示地对t2所引用的原对象进行释放操作，这就是智能指针的精髓所在。</p>
]]></content>
    </entry>
    
  
  
</search>
