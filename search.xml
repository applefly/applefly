<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[逻辑回归与线性回归原理探微]]></title>
      <url>http://onesimple.cn//blog/2017/02/logistic-regression/</url>
      <content type="html"><![CDATA[<p>&emsp;&emsp;回归和分类是机器学习解决的最重要的问题，本篇主要整理了线性回归和逻辑回归的基本推理过程和工程实践应用，首先对两种回归的方法做一下比较:</p>
<blockquote>
<p>线性回归: 最小二乘法推导，预测连续值</p>
<p>逻辑回归: 基于最大似然估计，主要解决二分类问题，也可用于连续值的预测</p>
</blockquote>
<a id="more"></a>
<h1 id="1-线性回归"><a href="#1-线性回归" class="headerlink" title="1.线性回归"></a>1.线性回归</h1><h2 id="问题引出"><a href="#问题引出" class="headerlink" title="问题引出"></a>问题引出</h2><p>&emsp;&emsp;房价y和房屋面积x之间的关系，我们一般估计为线性关系，即目标函数为:</p>
<p>$$<br>    f(x) = ax + b<br>$$<br>$$<br>   f(x) \approx  y<br>$$<br>根据样本很容易计算出a、b，也就能根据一个给定的面积x估算出房价了。\<br>如果有影响房价的不止一个因素(现实中往往如此，比如国民平均收入水平也是影响房价的一个因素)，就是一个多变量问题，这时我们估计的目标函数就变成多元的了，如果有m个因素,记为列向量:<br>$$\sum_{i=1}^n a_i=0$$</p>
<p>$$<br>    x = (x_0,x_1,…,x_{m-1})<br>$$<br>则要求解的参数w的也应该是m个，也记为列向量<br>$$<br>    w =<br>        \left (<br>            \begin{matrix}<br>                w_0 \\<br>                w_1 \\<br>                … \\<br>                w_{m-1}<br>            \end{matrix}<br>        \right )<br>$$<br>预测的f(x)是一个值，<code>f(x) = ax +b</code>的形式就变成:<br>$$<br>    f = xw<br>$$<br>推广到样本空间，记第i个样本为:<br>$$<br>    x_i = (x_{i0}, x_{i1},…,x_{i,m-1})<br>$$<br>如果有n个样本，样本空间表示为矩阵X:<br>$$<br>    X_{n \times m} =<br>        \left (<br>            \begin{matrix}<br>                x_{00} &amp; x_{01} &amp; … &amp; x_{0,m-1} \\<br>                x_{10} &amp; x_{11} &amp; … &amp; x_{1,m-1} \\<br>                …    &amp; … &amp; … &amp; …          \\<br>                x_{n-1,0} &amp; x_{n-1,1} &amp; … &amp; x_{n-1,m-1}<br>            \end{matrix}<br>        \right )<br>$$<br>则预测的所有f值的向量为:<br>$$<br>    f_{n \times 1} =<br>            \left (<br>            \begin{matrix}<br>                f_0 \\<br>                f_1 \\<br>                … \\<br>                f_{n-1}<br>            \end{matrix}<br>        \right )<br>        =<br>        X_{n \times m}w_{m \times 1}<br>$$<br>预测值和实际值一般会有一个误差，记为e<br>$$<br>  y_{n \times 1} = f_{n \times 1} + e_{n \times 1}<br>$$<br>任意第i个样本跟预测结果的误差的分布是随机的，既然是随机的，根据中心极限定理就可以估计其分布为正态分布，均值为0，方差为定值，则依据正态分布的概率密度定义,预测值与实际值之间误差的概率密度为:</p>
<p>$$<br>  p({e^{(i)}}) = \frac    {1}<br>      {<br>           \sqrt[2]  {2\pi}<br>           \sigma<br>      }<br>      e^{( - \frac { ( {e^{(i)}} ) ^ 2}<br>          {2\sigma^2}<br>      )}<br>$$<br>其中<br>$$<br>{e^{(i)}} = {y^{(i)}} - w_{m \times 1}^T {x_{m \times 1}^{(i)}}<br>$$<br>此式代入上式。假定n个样本独立，则n个样本的最大似然函数是各自概率密度的乘积:<br>$$<br>L(w) = \prod_{i=1}^{n} \frac    {1}<br>      {<br>           \sqrt[2]  {2\pi}<br>           \sigma<br>      }<br>      e^{( - \frac { ( {e^{(i)}} ) ^ 2}<br>          {2\sigma^2}<br>      )}<br>$$<br>此式是关于w的似然函数，要求的是w，可以先对上式取对数,得:<br>$$<br>l(w) = \sum_{i=1}^{n} \ln  [ {<br>       \frac    {1}<br>      {<br>           \sqrt[2]  {2\pi}<br>           \sigma<br>      }<br>      e^{( - \frac { ( {e^{(i)}} ) ^ 2}<br>          {2\sigma^2}<br>      )}<br>      } ]    \\\\<br>     = n \ln (\frac {1} { \sqrt[2]  {2\pi} \sigma }) -<br>     \frac {1} {2\sigma^2} \sum_{i=1}^{n} ({y^{(i)}} - w_{n \times 1}^T {x_{n \times 1}^{(i)}})^2<br>$$<br>前半项是常数项，记后半项为:<br>$$ \begin{equation}<br>J(w) = \frac {1} {2} {\sum_{i=1}^{n} ({y^{(i)}} - w_{n \times 1}^T {x_{n \times 1}^{(i)}})^2} \\\\<br>     = \frac {1} {2} {\sum_{i=1}^{n} (f_w(x) - y)^2}<br>     \label{a0} \end{equation}<br>$$</p>
<blockquote>
<p>l(w) J(w) 都是一个数值，根据最大似然估计法，概率总和最大时参数估计的最合理，则最大似然函数L(w)取最大时，可推出J(w)取最小，J(w)为最小二乘法的目标函数，问题变为求目标函数最小值的问题。</p>
</blockquote>
<h2 id="参数学习"><a href="#参数学习" class="headerlink" title="参数学习"></a>参数学习</h2><p>X为nxm的样本矩阵，Y为nx1维列向量，J(w)可以写成以下形式:<br>$$<br>\begin{equation}<br>J(w) = \frac {1} {2} (Xw - Y)^T(Xw - Y)<br>\label{a1}<br>\end{equation}<br>$$<br>要求J(w)的极值，可对上式求偏导:<br>$$<br>\nabla _w J(w) = \nabla _w (Xw - Y)^T(Xw - Y) \\\\<br>= \nabla _w (w^T X^T X w - w^T X^T Y - Y^T X w - Y^T Y) \\\\<br>= 2 X^T X w - X^T Y - (Y^T X)^T \\\\<br>= 2 ( X^T X w - X^T Y )<br>$$</p>
<p>注意:</p>
<blockquote>
<p>$Y^T X$  是常数项对w求偏导为0<br>$ \frac{\partial Xw}{\partial w} = X^\mathrm {T} $</p>
</blockquote>
<p>令上式偏导等于0，求解w:<br>$$<br>w = ( X^\mathrm {T} X ) ^ {-1} X^\mathrm {T} Y<br>$$<br>为防止$ X^\mathrm {T} X $ 不可逆或者防止过拟合，增加扰动$\lambda $<br>$$<br>\begin{equation}<br>w = ( X^\mathrm {T} X + \lambda I ) ^ {-1} X^\mathrm {T} Y<br>\label{a2}<br>\end{equation}<br>$$<br>I为单位阵，以上就是线性回归数理上的最终结论。</p>
<h2 id="正则化处理"><a href="#正则化处理" class="headerlink" title="正则化处理"></a>正则化处理</h2><p>过拟合是指在样本集上表现良好，但测试集上不好，一般是w中有些值过大，振荡很大，而导致过拟合。<br>为解决这个问题可以让更多的$w_j$取0，且越多越好，这种处理方法叫$L_0$正则化；<br>一般是让$ \sum_{j=1}^{m} |w_j| $ 取最小，这种处理叫$L_0$正则化；<br>如果是让$ \sum_{j=1}^{m} |w_j|^2 $ 取最小，则称谓$L_2$正则化。<br>故目标函数 $(\ref{a1})$ 加入平方和损失:<br>$$<br>\begin{equation}<br>J(w) = \frac {1} {2} (Xw - Y)^T(Xw - Y) + \lambda \sum_{j=1}^{m} {w_j}^2<br>\end{equation}<br>$$<br>根据此式进行求解也能推出w的求解公式$(\ref{a2})$</p>
<h2 id="训练与评价"><a href="#训练与评价" class="headerlink" title="训练与评价"></a>训练与评价</h2><p>怎么对样本进行训练呢?对于正则化项$\lambda$,怎么取值合理呢？</p>
<p>|  <strong><code>------- 1 -------</code></strong>    | <strong><code>-- 2 --</code></strong> |<strong><code>-- 3 --</code></strong>|</p>
<p>按合适比例划分样本，得到1、2、3三个部分<br>区间1用于训练w<br>区间2可以试用不同的$\lambda$，使用$w+\lambda I $作预测，看$\lambda$取多少时预测的准确，则选定此$\lambda$，这个过程不需要严格。<br>区间3对w、$\lambda$ 进行验证，当然，还有些交叉验证的策略。<br>|  <strong><code>------------  训练 -------------</code></strong>    | <strong><code>10% 验证</code></strong> |<br>|  <strong><code>--------  训练 ---------</code></strong>    | <strong><code>10%验证</code></strong> | <strong><code>- 训练-</code></strong> |<br>… …       交叉训练验证走十次       … …</p>
<h2 id="梯度下降算法"><a href="#梯度下降算法" class="headerlink" title="梯度下降算法"></a>梯度下降算法</h2><p>公式$(\ref{a2})$是参数w的解析解,但实际工程中样本空间很大，不可能对样本空间进行矩阵运算，所以这就需要机器学习的思路，从参数迭代的角度来求解w,梯度下降是常用的算法。</p>
<blockquote>
<p>其意义是，为了求得函数的极值点(局部最小值)，先任取一点，然后沿此点处梯度的负方向进行迭代到一个新的点，继续下降直到收敛，算法结束。</p>
</blockquote>
<p>首先我们来对$(\ref{a0})$某个$w_j$求偏导<br>$$<br> \frac{\partial J(w)}{\partial w_j} = \frac{\partial }{\partial w_j} { \frac {1} {2} (f_w (x) - y)^2 } \\\\<br> = (f_w (x) - y) \cdot \frac{\partial }{\partial w_j} (f_w (x) - y)\\\\<br> = (f_w (x) - y) \cdot \frac{\partial }{\partial w_j} (\sum_{k=1}^{m} w_k x_k - y) \\\\<br> = (f_w (x) - y) x_j<br>$$<br>注意，上式除了$w_j$其他都算常量，所以求导得到上式结果。结论可简记为：</p>
<blockquote>
<p>某个维度的梯度 = 预测误差 X 样本在该维度的取值</p>
</blockquote>
<p>既然有了这个梯度，我们就可以有以下几种方式计算。</p>
<h3 id="批量梯度下降"><a href="#批量梯度下降" class="headerlink" title="批量梯度下降"></a>批量梯度下降</h3><p><strong>批量梯度下降是对所有样本的梯度做加和，然后按步长进行下降迭代，直到收敛</strong></p>
<p>while  重复直到收敛 :  {<br>$$ w_j = w_j + \alpha \sum_{i=1}^{n} [ (y^{(i)} - f_w(x^{(i)})) \cdot x_j^{(i)} ] $$<br>}<br>$\alpha$为每次迭代的步长<br>凸函数局部最小值一定是全局最小值，批量梯度下降一定会收敛。<br>初始可以让w都为0</p>
<h3 id="随机梯度下降SGD"><a href="#随机梯度下降SGD" class="headerlink" title="随机梯度下降SGD"></a>随机梯度下降SGD</h3><p>随机梯度下降也称SGD<br><strong>针对每来一个样本进行一次迭代，而不是对所有样本的梯度做加和做迭代</strong><br>while 迭代次数  :  {<br>&emsp;&emsp;for i = 0 to n : {<br>$$<br>w_j = w_j + \alpha (y^{(i)} - f_w(x^{(i)})) \cdot x_j^{(i)}<br>$$<br>&emsp;&emsp;}<br>}<br>注:可以通过最大迭代次数来退出loop，也可以判断本次参数$w_j^{(k)}$ 和下次的$w_j^{(k+1)}$之间的误差，如果稳定到很小的值，则认为收敛，可以退出。</p>
<blockquote>
<p>全局梯度下降有可能在一些拐点位置停止不前，而随机梯度下降就或许能跳过一些拐点到达真正的收敛点附近，这是梯度下降的一些特点，以后有机会附文研讨。<br>随机梯度下降一般速度会比较快，学习步长也可以让它先大后小。</p>
</blockquote>
<h3 id="mini-batch梯度下降"><a href="#mini-batch梯度下降" class="headerlink" title="mini-batch梯度下降"></a>mini-batch梯度下降</h3><p>基于以上两种算法的折中算法，每次随机选取b个样本做一个批量梯度下降，这样既节省了计算整个批量的时间，同时计算的方向也会像SGD一样更加准确。<br>repeat until convergency{<br>&emsp;&emsp;for i=1;i&lt;n ; i+=b: {<br>$$ w_j = w_j + \alpha \sum_{i=1}^{i+b} [ (y^{(i)} - f_w(x^{(i)})) \cdot x_j^{(i)} ] $$<br>&emsp;&emsp;}<br>}
　</p>
<h1 id="2-非线性回归"><a href="#2-非线性回归" class="headerlink" title="2.非线性回归"></a>2.非线性回归</h1><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>其实只是特征增加了$x^2$项，y相对于特征是非线性的，相对于w还是线性的。往往可以先通过变量置换，$x^{‘} = x^2$把非线性回归化为线性回归，再利用线性回归的方法确定参数及估计值。</p>
<blockquote>
<p><strong>局部加权回归暂不介绍</strong></p>
</blockquote>
<h1 id="3-逻辑回归"><a href="#3-逻辑回归" class="headerlink" title="3.逻辑回归"></a>3.逻辑回归</h1><h2 id="问题引出-1"><a href="#问题引出-1" class="headerlink" title="问题引出"></a>问题引出</h2><p>线性回归适合预测连续值，在解决分类问题时则有些不合理，比如<br>如果只有A B 两簇，线性回归拟合直线为$L_1$,此时取定义域中点a处的值作为界限进行分类，可能暂时满足。但当是ABC三簇数据时，再依此法取b出的值作为分类界限，就会发现分类很不合理。所以线性回归解决分类问题是不合理的，而逻辑回归则适合解决二分类问题。(如果解决多分类问题，可使用softmax回归)</p>
<center><br><img title="线性回归拟合直线" alt="线性回归拟合直线" class="class1 class2" src="http://okqpu7sb4.bkt.clouddn.com//image/data/line-rg1.png?imageView2/2/w/600"><br></center>

<center><br>《—- 待续 —-》<br></center>



]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[hexo博客之常用markdown语法及latex公式备忘]]></title>
      <url>http://onesimple.cn//blog/2017/01/write-blog-with-hexo/</url>
      <content type="html"><![CDATA[<p>本篇主要整理了一些常用的markdown语法，以及hexo博客使用mathjax渲染公式的一些样例。</p>
<a id="more"></a>
<ul>
<li>图片居中<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;center&gt;</div><div class="line">&#123;% qnimg user/alipay.jpg title:微信二维码 alt:二维码 &apos;class:class1 class2&apos; extend:?imageView2/2/w/600 %&#125;</div><div class="line">&lt;/center&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<center><br><img title="支付宝二维码" alt="二维码" class="class1 class2" src="http://okqpu7sb4.bkt.clouddn.com//image/user/alipay.jpg?imageView2/2/w/600"><br></center>

<ul>
<li>mathjax 公式测试<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">段内公式只用一个$即可:  $F_&#123;\mu&#125;$</div></pre></td></tr></table></figure>
</li>
</ul>
<p>&emsp;&emsp;这是我的段内公式: $F_{\mu}$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$$\sum_&#123;i=1&#125;^n a_i=0$$</div></pre></td></tr></table></figure>
<p>$$\sum_{i=1}^n a_i=0$$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$F_&#123;\mu&#125;$</div><div class="line"></div><div class="line">$F_1 + F_b = F_c$</div><div class="line"></div><div class="line">$$</div><div class="line">f(x) \approx  y</div><div class="line">$$</div></pre></td></tr></table></figure>
<p>$F_{\mu}$</p>
<p>$F_1 + F_b = F_c$</p>
<p>$$<br>f(x) \approx  y<br>$$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$x = ( x_0 , x_1 , ... , x_&#123;m-1&#125; )$</div></pre></td></tr></table></figure>
<p>$x = ( x_0 , x_1 , … , x_{m-1} )$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$$\sum_&#123;i=1&#125;^n a_i=0$$</div></pre></td></tr></table></figure>
<p>$$\sum_{i=1}^n a_i=0$$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$x = ( x_0 , x_1 , ... , x_&#123;m-1&#125; )$</div></pre></td></tr></table></figure>
<p>$x = ( x_0 , x_1 , … , x_{m-1} )$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$$</div><div class="line">\begin&#123;bmatrix&#125;</div><div class="line">1 &amp; 2\\</div><div class="line">3 &amp; 4</div><div class="line">\end&#123;bmatrix&#125;</div><div class="line">$$</div></pre></td></tr></table></figure>
<p>$$<br>\begin{bmatrix}<br>1 &amp; 2\\<br>3 &amp; 4<br>\end{bmatrix}<br>$$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$$</div><div class="line">    w = </div><div class="line">        \left (</div><div class="line">            \begin&#123;matrix&#125; </div><div class="line">                w\_0 \\</div><div class="line">                w\_1 \\</div><div class="line">                ... \\</div><div class="line">                w\_&#123;m-1&#125; </div><div class="line">            \end&#123;matrix&#125;</div><div class="line">        \right )</div><div class="line">$$</div></pre></td></tr></table></figure>
<p>$$<br>    w =<br>        \left (<br>            \begin{matrix}<br>                w_0 \\<br>                w_1 \\<br>                … \\<br>                w_{m-1}<br>            \end{matrix}<br>        \right )<br>$$</p>
<ul>
<li>表格测试<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">| 链接 | 结果 | 原因 |</div><div class="line">|:-----|:---:|----------:|</div><div class="line">|文本内容| **`是`** |同协议同域名同端口|</div><div class="line">|文本内容| **`是`** |同协议同域名同端口|</div><div class="line">|文本内容| **`是`** |同协议同域名同端口|</div></pre></td></tr></table></figure>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">链接</th>
<th style="text-align:center">结果</th>
<th style="text-align:right">原因</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">文本内容</td>
<td style="text-align:center"><strong><code>是</code></strong></td>
<td style="text-align:right">同协议同域名同端口</td>
</tr>
<tr>
<td style="text-align:left">文本内容</td>
<td style="text-align:center"><strong><code>是</code></strong></td>
<td style="text-align:right">同协议同域名同端口</td>
</tr>
<tr>
<td style="text-align:left">文本内容</td>
<td style="text-align:center"><strong><code>是</code></strong></td>
<td style="text-align:right">同协议同域名同端口</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[(转)C/C++ 程序的性能分析工具 google-perftools]]></title>
      <url>http://onesimple.cn//blog/2016/09/google-perftools/</url>
      <content type="html"><![CDATA[<p>&emsp;&emsp;google-perftools 是一款针对 C/C++ 程序的性能分析工具，它是一个遵守 BSD 协议的开源项目。使用该工具可以对 CPU 时间片、内存等系统资源的分配和使用进行分析，本文将重点介绍如何进行 CPU 时间片的剖析。 google-perftools 对一个程序的 CPU 性能剖析包括以下几个步骤。</p>
<a id="more"></a>
<blockquote>
<ol>
<li>编译目标程序，加入对 google-perftools 库的依赖。</li>
<li>运行目标程序，并用某种方式启动 / 终止剖析函数并产生剖析结果。</li>
<li>运行剖结果转换工具，将不可读的结果数据转化成某种格式的文档（例如 pdf,txt,gv 等）。</li>
</ol>
</blockquote>
<ul>
<li>安装</li>
</ul>
<p>&emsp;&emsp;您可以在 google-perftools 的网站 (<a href="http://code.google.com/p/google-perftools/downloads/list" target="_blank" rel="external">http://code.google.com/p/google-perftools/downloads/list</a>) 上下载最新版的安装包。为完成步骤 3 的工作，您还需要一个将剖析结果转化为程序员可读文档的工具，例如 gv（<a href="http://www.gnu.org/software/gv/）。" target="_blank" rel="external">http://www.gnu.org/software/gv/）。</a></p>
<ul>
<li>编译与运行</li>
</ul>
<p>&emsp;&emsp;您需要在原有的编译选项中加入对 libprofiler.so 的引用，这样在目标程序运行时会加载工具的动态库。例如本例中作者的系统中，libprofiler.so 安装在”/usr/lib”目录下，所以需要在 makefile 文件中的编译选项加入“-L/usr/lib -lprofiler”。</p>
<p>&emsp;&emsp;google-perftools 需要在目标代码的开始和结尾点分别调用剖析模块的启动和终止函数，这样在目标程序运行时就可以对这段时间内程序实际占用的 CPU 时间片进行统计和分析。工具的启动和终止可以采用以下两种方式。</p>
<p>&emsp;&emsp;a. 使用调试工具 gdb 在程序中手动运行性能工具的启动 / 终止函数。</p>
<p>&emsp;&emsp;gdb 是 Linux 上广泛使用的调试工具，它提供了强大的命令行功能，使我们可以在程序运行时插入断点并在断点处执行其他函数。具体的文档请参照 <a href="http://www.gnu.org/software/gdb/，本文中将只对用到的几个基本功能进行简单介绍。使用以下几个功能就可以满足我们性能" target="_blank" rel="external">http://www.gnu.org/software/gdb/，本文中将只对用到的几个基本功能进行简单介绍。使用以下几个功能就可以满足我们性能</a> 调试的基本需求，具体使用请参见下文示例。<br> 命令功能</p>
<blockquote>
<p>ctrl+c    暂停程序的运行 c    继续程序的运行 b    添加函数断点（参数可以是源代码中的行号或者一个函数名）<br>p    打印某个量的值或者执行一个函数调用 </p>
</blockquote>
<p>&emsp;&emsp;b. 在目标代码中直接加入性能工具函数的调用，该方法就是在程序代码中直接加入调试函数的调用。<br>&emsp;&emsp;两种方式都需要对目标程序重新编译，加入对性能工具的库依赖。对于前者，他的好处是使用比较灵活，但工具的启动和终止依赖于程序员的手动操作，常常 需要一 些暂停函数（比如休眠 sleep）的支持才能达到控制程序的目的，因此精度可能受到影响。对于后者，它需要对目标代码的进行修改，需要处理函数声明等问题，但得到的结果精度较 高，缺点是每次重新设置启动点都需要重新编译，灵活度不高，读者可以根据自己的实际需求采用有效的方式。</p>
<ul>
<li>示例详解</li>
</ul>
<p>&emsp;&emsp;该程序是一个简单的例子，文中有两处耗时的无用操作，并且二者间有一定的调用关系。</p>
<p>清单 1. 示例程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">void consumeSomeCPUTime1(int input)&#123; </div><div class="line">  int i = 0; </div><div class="line">  input++; </div><div class="line">  while(i++ &lt; 10000)&#123; </div><div class="line">    i--;  i++;  i--;  i++; </div><div class="line">  &#125; </div><div class="line"> &#125;; </div><div class="line"></div><div class="line"> void consumeSomeCPUTime2(int input)&#123; </div><div class="line">  input++; </div><div class="line">  consumeSomeCPUTime1(input); </div><div class="line">  int i = 0; </div><div class="line">  while(i++ &lt; 10000)&#123; </div><div class="line">    i--;  i++;  i--;  i++; </div><div class="line">  &#125; </div><div class="line"> &#125;; </div><div class="line"></div><div class="line"> int stupidComputing(int a, int b)&#123; </div><div class="line">  int i = 0; </div><div class="line">  while( i++ &lt; 10000)&#123;  </div><div class="line">    consumeSomeCPUTime1(i); </div><div class="line">  &#125; </div><div class="line">  int j = 0; </div><div class="line">  while(j++ &lt; 5000)&#123; </div><div class="line">    consumeSomeCPUTime2(j); </div><div class="line">  &#125; </div><div class="line">  return a+b; </div><div class="line"> &#125;; </div><div class="line"></div><div class="line"> int smartComputing(int a, int b)&#123; </div><div class="line">  return a+b; </div><div class="line"> &#125;; </div><div class="line"></div><div class="line"> void main()&#123; </div><div class="line">  int i = 0;</div><div class="line">  printf(&quot;reached the start point of performance bottle neck\n&quot;); </div><div class="line">  sleep(5);</div><div class="line">				//ProfilerStart(&quot;CPUProfile&quot;);</div><div class="line">  while( i++ &lt; 10)&#123; </div><div class="line">    printf(&quot;Stupid computing return : %d\n&quot;,stupidComputing(i, i+1)); </div><div class="line">    printf(&quot;Smart computing return %d\n&quot;,smartComputing(i+1, i+2)); </div><div class="line">  &#125;</div><div class="line">  printf(&quot;should teminate profiling now.\n&quot;);  </div><div class="line">  sleep(5);</div><div class="line">				//ProfilerStop();</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;源代码中粗体的内容（方法 1）和斜体的内容（方法 2）分别代表了上文中提及胡两种执行剖析的方式。采用方法二时将直接产生结果，采用方法 1 时需要配合 GDB 的命令来实现剖析的执行和结束，可用的方法有两种，一种是在程序运行时手动暂停函数的执行，另一种是预设断点，并在断点处执行剖析函数，两种方法（方法 a，方法 b）在命令行中的具体操作如下。<br>&emsp;&emsp;方法 a</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">gdb YOUR_PROGRAM // 启动 gdb 并选择你的程序为 gdb 的启动目标 </div><div class="line">(gdb)r // 运行 </div><div class="line">// 等待你需要的条件满足，此处示例中打印了字符 </div><div class="line">(gdb)Ctrl + c // 暂停当前函数 </div><div class="line">(gdb)p ProfilerStart(&quot;MyProfile&quot;)</div><div class="line">(gdb)c // 继续程序运行 </div><div class="line">// 等待程序打印目标模块结束，此处示例打印了提示 </div><div class="line">(gdb)Ctrl + c // 暂停当前函数 </div><div class="line">(gdb)p ProfilerStop()</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;方法 b</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">gdb YOUR_PROGRAM // 启动 gdb 并选择你的程序为 gdb 的启动目标 </div><div class="line">(gdb)b main1.c:47 // 对应于耗时模块的起始点 </div><div class="line">(gdb)b main1.c:52 // 对应于耗时模块的终止点 </div><div class="line">(gdb)r // 运行 </div><div class="line">(gdb)p ProfilerStart(&quot;MyProfile&quot;)</div><div class="line">(gdb)c // 继续程序运行 </div><div class="line">(gdb)p ProfilerStop()</div></pre></td></tr></table></figure>
<ul>
<li>结果分析</li>
</ul>
<p>&emsp;&emsp;程序执行完毕会在程序的当前工作目录下产生名为 MyProfile 的结果文件。我们可以用以下命令产生可视化的结果文档。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pprof --gv ./codeTest MyProfile</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;其中 codeTest 对应于用于测试的目标程序文件名，如果您安装了 pdf 相关的软件您还可以尝试生成 pdf 格式的结果文档，其对应的命令为 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pprof --pdf ./codeTest MyProfile &gt; MyProfile.pdf</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;转换后产生的结果文档如下图。图中的数字和框体的大小代表了的某个函数的运行时间占整个剖析时间的比例。由代码的逻辑可 知，stupidComputing，stupidComputing2 都是费时操作并且它们和 consumeSomeCPUTime 存在着一定的调用关系。</p>
<p>&emsp;&emsp;图 1. 剖析结果<br><img src="http://static.open-open.com/lib/uploadImg/20111223/20111223105703_200.gif" alt="这里写图片描述"><br>&emsp;&emsp;C/C++ 程序的性能分析工具 google-perftools</p>
<ul>
<li>结束语</li>
</ul>
<p>&emsp;&emsp;本文介绍了一个 Linux 平台上的性能剖析工具 google-perftools，并结合实例向读者展示了如何使用该工具配置、使用及分析性能瓶颈。</p>
<p>原文练级：<a href="http://www.open-open.com/lib/view/open1324609079218.html" target="_blank" rel="external">C/C++ 程序的性能分析工具 google-perftools</a><br>项目主页：<a href="http://www.open-open.com/lib/view/home/1324609079218" target="_blank" rel="external">http://www.open-open.com/lib/view/home/1324609079218</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[“只生一个娃”--设计模式中的单例模式（Singleton）]]></title>
      <url>http://onesimple.cn//blog/2015/07/singleton/</url>
      <content type="html"><![CDATA[<p>&emsp;&emsp;<strong>所谓单例模式（Singleton），即指一个类只有一个实例（Instance），并给外界提供访问该实例的一个全局访问点。</strong></p>
<a id="more"></a>
<hr>
<ul>
<li><p>引言<br>&emsp;&emsp;被人问到什么是单例模式，突然回答不上来，似乎印象不深了。回去补了一下功课，突然明白了，原来在项目中一直使用的日志模块即采用了单例模式，只是熟视无睹，没有意识到罢了。<br>&emsp;&emsp;<strong>所谓单例模式（Singleton），即指一个类只有一个实例（Instance），并给外界提供访问该实例的一个全局访问点。</strong><br>&emsp;&emsp;通常我们可以使用全局变量的方式来实现“只生一个娃”，但更好的方法就是：<strong>让该类自身负责创建和保存它的唯一实例</strong>。这个类可以保证没有其他实例可以被创建，并且对外提供一个访问该实例的方法。下面我们看一下具体实现。</p>
</li>
<li><p>单例模式实现<br>&emsp;&emsp;定义一个Singleton类，添加一个静态方法GetInstance，负责创建自己的唯一实例，并供客户端访问。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">class Singleton  </div><div class="line">&#123;  </div><div class="line">private:  </div><div class="line">    Singleton()  </div><div class="line">    &#123;  </div><div class="line">    &#125;  </div><div class="line">    static Singleton *m_pInstance;  </div><div class="line">    </div><div class="line">public:  </div><div class="line">    static Singleton * GetInstance()  </div><div class="line">    &#123;  </div><div class="line">	    if(m_pInstance == NULL)  //若不存在，则new一个新的实例。  </div><div class="line">				m_pInstance = new Singleton();  </div><div class="line">        return m_pInstance;  </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //可以定义一个具体干活的方法</div><div class="line">    void DoWork()</div><div class="line">    &#123;</div><div class="line">		printf(&quot;the work is done!&quot;);   </div><div class="line">    &#125;  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>&emsp;&emsp;注意：<strong>构造函数设为private，这样外界就不能通过new操作符来实例化该类。</strong><br>&emsp;&emsp;客户端访问方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Singleton* p1 = Singleton :: GetInstance();</div><div class="line">Singleton* p2 = p1-&gt;GetInstance();</div><div class="line">Singleton &amp; ref = * Singleton :: GetInstance();</div><div class="line"></div><div class="line">p1-&gt;DoWork();</div><div class="line">p2-&gt;DoWork();</div><div class="line">ref.DoWork();</div><div class="line">Singleton :: GetInstance()-&gt;DoWork();</div></pre></td></tr></table></figure>
<ul>
<li>问题讨论<br>多线程环境下，如果多个线程同时访问Singleton类的GetInstance方法，则有可能造成创建多个实例。因此应该进行加锁保护，可以使用lock机制，确保当一个线程位于代码的临界区时，另一个线程如果访问可被阻塞等待，不进入临界区。可以这样来实现:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">class Singleton  </div><div class="line">&#123;  </div><div class="line">private:  </div><div class="line">    Singleton()  </div><div class="line">    &#123;  </div><div class="line">    &#125;  </div><div class="line">	static Singleton *m_pInstance;</div><div class="line">	CCriticalSection m_cs;   //定义一个临界区对象</div><div class="line">public:  </div><div class="line">    static Singleton * GetInstance()  </div><div class="line">    &#123;  </div><div class="line">        if(NULL == m_pInstance)  //若不存在，则new一个新的实例。  </div><div class="line">        &#123;</div><div class="line">			lock(m_cs)         //尽在实例未被创建时进行加锁处理</div><div class="line">	      &#123;</div><div class="line">		      if(NULL == m_pInstance) //二次判断</div><div class="line">		      &#123;</div><div class="line">		             m_pInstance = new Singleton();  </div><div class="line">		      &#125;  </div><div class="line">	      &#125;</div><div class="line">        &#125;</div><div class="line">        return m_pInstance;  </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //可以定义一个具体干活的方法</div><div class="line">    void DoWork()</div><div class="line">    &#123;</div><div class="line">		printf(&quot;the work is done!&quot;);   </div><div class="line">    &#125;  </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;注意：为什么要二次判断呢？<br>&emsp;&emsp;第一次NULL == m_pInstance判断是为了避免每次都要加锁，能够提高效率；<br>&emsp;&emsp;第二次判断是因为：如果实例未被创建，两个线程同时通过第一层NULL == m_pInstance判断，由于lock机制，只有第一个线程进入，另一个排队等候，如果第一个线程创建了实例并出来后，第二个线程进入后还是可以创建新的实例的。</p>
<p>&emsp;&emsp;由此可见：想要保证只生一个小孩真是要时时留意、处处留心，安全措施要绝对保证啊 O(∩_∩)O.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[智能指针的实现机理]]></title>
      <url>http://onesimple.cn//blog/2015/07/principles-of-auto-pointer/</url>
      <content type="html"><![CDATA[<p>&emsp;&emsp;智能指针(smart pointer)是存储指向动态分配（堆）对象指针的类，用于生存期控制，能够确保自动正确的销毁动态分配的对象，防止内存泄露。它的一种通用实现技术是使用引用计数(reference count)，实现指针指向的对象的共享的。</p>
<a id="more"></a>
<ul>
<li>介绍</li>
</ul>
<p>其实现的基本思想：</p>
<p>&emsp;&emsp;1.每次创建类的新对象时，初始化指针并将<strong>引用计数</strong>置为1；<br>&emsp;&emsp;2.当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数；<br>&emsp;&emsp;3.对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数减至0，则删除对象），并增加右操作数所指对象的引用计数；<br>&emsp;&emsp;4.调用析构函数时，减少引用计数（如果引用计数减至0，则删除基础对象）；<br>&emsp;&emsp;4.重载“-&gt;”以及“*”操作符，使得智能指针有类似于普通指针的操作。<br>&emsp;&emsp;根据以上分析，首先可以得出下面的类模板原型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">template &lt;class T&gt;</div><div class="line">class SmartPointer</div><div class="line">&#123;</div><div class="line">public:</div><div class="line"></div><div class="line">	SmartPointer(T *p = 0);//构造函数</div><div class="line">	SmartPointer(const SmartPointer&amp; src);//拷贝构造函数</div><div class="line">	SmartPointer&amp; operator = (const SmartPointer&amp; rhs);//赋值函数</div><div class="line"></div><div class="line">	T* operator -&gt; ();//重载-&gt;</div><div class="line">	T&amp; operator * ();//重载*</div><div class="line">	~SmartPointer();//析构函数</div><div class="line"></div><div class="line">private:</div><div class="line"></div><div class="line">	void MinusRef()</div><div class="line">	&#123;</div><div class="line">		//被其他成员函数所调用</div><div class="line">		if (--*m_pRef == 0)//自身的引用计数减1</div><div class="line">		&#123;</div><div class="line">			//如果计数为0，则释放内存</div><div class="line">			delete m_ptr;</div><div class="line"></div><div class="line">			delete m_pRef;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	T *m_ptr;							//保存对象指针</div><div class="line">	size_t *m_pRef;						//保存引用计数</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;上面的私有成员函数MinusRef将引用计数减1。如果引用计数减至0，则删除m_ptr所指对象。根据前面的分析，MinusRef只被赋值函数以及析构函数使用。<br>下面说明各个成员的具体定义。<br>&emsp;&emsp;首先是构造函数与析构函数的定义。普通构造函数中，m_ptr与p指向同一块内存，并初始化引用计数为1。拷贝构造函数中与普通构造函数的不同之处为引用计数需要加1。析构函数调用私有成员MinusRef对引用计数递减，并且判断是否需要释放对象。代码如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">template&lt;class T&gt;</div><div class="line">SmartPointer&lt;T&gt;::SmartPointer(T *p)		//普通构造函数</div><div class="line">&#123;</div><div class="line">	m_ptr = p;							//m_ptr与p指向同一内存</div><div class="line">	m_pRef = new size_t(1);				//m_pRef初值为1</div><div class="line">&#125;</div><div class="line"></div><div class="line">template&lt;class T&gt;</div><div class="line">SmartPointer&lt;T&gt;::SmartPointer(const SmartPointer&lt;T&gt;&amp; src)//拷贝构造函数</div><div class="line">&#123;</div><div class="line">	m_ptr = src.m_ptr;		//m_ptr与src.m_ptr指向同一内存</div><div class="line">	m_pRef++;</div><div class="line">	m_pRef = src.m_pRef;	//拷贝引用计数</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">template&lt;class T&gt;</div><div class="line">SmartPointer&lt;T&gt;::~SmartPointer()		//析构函数</div><div class="line">&#123;</div><div class="line">	MinusRef();				//引用减1,如果减后的引用为0，则释放内存</div><div class="line">	std::cout&lt;&lt;&quot;SmartPointer: Destructor&quot;&lt;&lt;std::endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;接下来是“-&gt;”和“*”的重载。这两个函数很简单，只需要分别返回m_ptr以及m_ptr所指的内容即可。注意，如果m_ptr此时为空，则应该抛出异常。代码如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">template&lt;class T&gt;</div><div class="line">T* SmartPointer&lt;T&gt;::operator -&gt; ()	//重载 -&gt;</div><div class="line">&#123;</div><div class="line">	if (m_ptr)</div><div class="line">		return m_ptr;</div><div class="line"></div><div class="line">	//m_ptr为NULL时，抛出异常</div><div class="line"></div><div class="line">	throw std::runtime_error(&quot;access through NULL pointer&quot;);</div><div class="line">&#125;</div><div class="line">template&lt;class T&gt;</div><div class="line">T&amp; SmartPointer&lt;T&gt;::operator * () //重载 *</div><div class="line">&#123;</div><div class="line">	if (m_ptr)</div><div class="line">		return *m_ptr;</div><div class="line">	//m_ptr为NULL时，抛出异常</div><div class="line"></div><div class="line">	throw std::runtime_error(&quot;dereference of NULL pointer&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;最后是赋值函数的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">template&lt;class T&gt;</div><div class="line"></div><div class="line">SmartPointer&lt;T&gt;&amp; SmartPointer&lt;T&gt;::operator = (const SmartPointer&lt;T&gt;&amp; rhs)//赋值函数</div><div class="line">&#123;</div><div class="line">	++*rhs.m_pRef;		//rhs的引用加1</div><div class="line">	MinusRef();			//自身指向的原指针的引用减1</div><div class="line">	m_ptr = rhs.m_ptr;	//m_ptr合rhs.m_ptr指向同一个对象</div><div class="line">	m_pRef = rhs.m_pRef; //复制引用</div><div class="line">	return *this;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;这样，就可以像 std::auto_ptr那样来使用SmartPointer。以下先定义一个测试类，测试程序如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">class Test</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	Test() &#123;name = NULL;&#125;</div><div class="line">	Test(const char* strname)//构造函数</div><div class="line">	&#123;</div><div class="line">		name = new char[strlen(strname)+1];//分配内存</div><div class="line">		strcpy(name, strname);//拷贝字符串</div><div class="line">	&#125;</div><div class="line">	Test&amp; operator = (const char *namestr)//赋值函数</div><div class="line">	&#123;</div><div class="line">		if (name != NULL)</div><div class="line">		&#123;</div><div class="line">			delete name;//释放原来的内存</div><div class="line">		&#125;</div><div class="line">		name = new char[strlen(namestr)+1];//分配新内存</div><div class="line">		strcpy(name, namestr);//拷贝字符串</div><div class="line">		return *this;</div><div class="line">	&#125;</div><div class="line">	void ShowName() &#123;cout &lt;&lt; name &lt;&lt; endl;&#125;</div><div class="line">	~Test()</div><div class="line">	&#123;</div><div class="line">		if (name != NULL)</div><div class="line">		&#123;</div><div class="line">			delete name;</div><div class="line">		&#125;</div><div class="line">		name = NULL;</div><div class="line">		cout &lt;&lt; &quot;delete name&quot; &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line">public:</div><div class="line">	char *name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">int _tmain(int argc, _TCHAR* argv[])</div><div class="line">&#123;</div><div class="line">	SmartPointer&lt;Test&gt; t1;//空指针</div><div class="line">	SmartPointer&lt;Test&gt; t2(new Test(&quot;fefd&quot;));</div><div class="line">	SmartPointer&lt;Test&gt; t3(new Test(&quot;wewew&quot;));</div><div class="line">	try</div><div class="line">	&#123;</div><div class="line">		t1-&gt;ShowName();//空指针调用抛出异常</div><div class="line">	&#125;</div><div class="line">	catch (const exception&amp; err)</div><div class="line">	&#123;</div><div class="line">		cout &lt;&lt; err.what() &lt;&lt; endl;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	t2-&gt;ShowName();		//使用t2调用showName()</div><div class="line">	*t2 = &quot;David&quot;;		//使用t2给对象赋值</div><div class="line">	t2-&gt;ShowName();		//使用t2调用showName()</div><div class="line">	t2 = t3;			//赋值，原来t2的对象引用为0，发生析构</div><div class="line">						//而t3的对象引用加1</div><div class="line">	cout &lt;&lt; &quot;End of main...&quot; &lt;&lt; endl;</div><div class="line"></div><div class="line">	getchar();</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;main函数代码第41行，t1指向一个NULL指针，因此调用ShowName时会出现异常（异常在重载的“-&gt;”函数中被抛出）。<br>&emsp;&emsp;main函数代码第48～50行，使用SmartPtr对象对Test对象进行操作，其方法与使用Test对象指针的操作方法相同。<br>&emsp;&emsp;main函数代码第51行，对t2进行赋值操作，操作完成后，t2引用的原对象发生析构（此对象没有SmartPtr对象引用了），t2和t3引用同一个对象，于是这个对象的引用计数加1。注意，这里我们并没有显示地对t2所引用的原对象进行释放操作，这就是智能指针的精髓所在。</p>
]]></content>
    </entry>
    
  
  
</search>
